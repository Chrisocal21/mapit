<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>maprdy - Map to Laser Ready</title>
    <meta name="description" content="Transform any location into laser-ready artwork. Professional map processing for laser engraving and wall art.">
    <meta property="og:title" content="maprdy - Map to Laser Ready">
    <meta property="og:description" content="Transform any location into laser-ready artwork. Professional map processing for laser engraving and wall art.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://maprdy.com">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="icon" type="image/svg+xml" href="maprdylogo.svg">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        /* Header */
        header {
            background: #2c2c2c;
            color: #fff;
            padding: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .header-top {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            background: #1e1e1e;
            gap: 1rem;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
            color: #fff;
        }

        .search-container {
            position: relative;
            flex: 1;
            max-width: 400px;
            min-width: 250px;
        }

        #searchInput {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            font-size: 0.875rem;
            background: #3c3c3c;
            color: #fff;
            transition: all 0.2s;
        }

        #searchInput::placeholder {
            color: #888;
        }

        #searchInput:focus {
            outline: none;
            border-color: #4a90e2;
            background: #454545;
        }

        #searchResults {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e0e0e0;
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1001;
        }

        .search-result-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            color: #333;
            font-size: 0.9rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .result-icon {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            color: #4a9eff;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .result-content {
            flex: 1;
            min-width: 0;
        }

        .result-name {
            font-weight: 500;
            color: #000;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-context {
            font-size: 0.75rem;
            color: #666;
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, #4a9eff, #00bfff);
            transform: scaleY(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .search-result-item:hover {
            background: linear-gradient(90deg, rgba(74, 158, 255, 0.08), rgba(74, 158, 255, 0.02));
            padding-left: 1.25rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .search-result-item:hover::before {
            transform: scaleY(1);
        }

        .search-result-item:hover .result-icon {
            transform: scale(1.2);
            color: #00bfff;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        /* Toolbar Group Styles (no longer using separate toolbar div) */

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0 0.5rem;
            border-left: 1px solid #404040;
        }

        .toolbar-group:first-child {
            border-left: none;
            padding-left: 0;
        }

        .toolbar-label {
            font-size: 0.75rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
            margin-right: 0.25rem;
        }

        .toolbar select,
        .toolbar input[type="number"] {
            padding: 0.375rem 0.5rem;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            font-size: 0.8rem;
            background: #3c3c3c;
            color: #fff;
            min-width: 80px;
        }

        .toolbar select:focus,
        .toolbar input:focus {
            outline: none;
            border-color: #4a90e2;
            background: #454545;
        }

        .toolbar-button {
            padding: 0.375rem 0.75rem;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            font-size: 0.75rem;
            background: #3c3c3c;
            color: #fff;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .toolbar-button:hover {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        .toolbar-button.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }
        
        @keyframes flash {
            0%, 100% { background: #4a90e2; box-shadow: 0 0 10px #4a90e2; }
            50% { background: #66a3e0; box-shadow: 0 0 20px #4a90e2; }
        }
        
        .toolbar-button.flash {
            animation: flash 0.6s ease-in-out 3;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.2s ease;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #e0e0e0;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 28px;
            line-height: 1;
            color: #888;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            background: #3a3a3a;
            color: #e0e0e0;
        }
        
        .modal-body {
            padding: 24px;
            overflow-y: auto;
            color: #e0e0e0;
        }
        
        .btn-secondary {
            transition: all 0.2s ease;
        }
        
        .btn-secondary:hover {
            background: #4a4a4a !important;
        }
        
        .btn-primary {
            transition: all 0.2s ease;
        }
        
        .btn-primary:hover {
            background: #5a9ee8 !important;
        }
        
        .spinner {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            width: 20px;
            height: 20px;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .toolbar-badge {
            display: inline-block;
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 0.25rem;
        }

        .toolbar-badge.orange {
            background: #ff9800;
            color: #fff;
        }

        .toolbar-badge.green {
            background: #28a745;
            color: #fff;
        }

        .toolbar-badge.blue {
            background: #4a90e2;
            color: #fff;
        }

        /* Dropdown Menu Styles */
        .menu-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            flex: 1;
        }

        .menu-item {
            position: relative;
        }

        .menu-button {
            padding: 0.5rem 0.75rem;
            background: #3c3c3c;
            border: 1px solid #3c3c3c;
            color: #fff;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .menu-button:hover {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        .menu-button.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        .menu-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 0.25rem;
            background: #2c2c2c;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 0.5rem 0;
            min-width: 200px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .menu-dropdown.show {
            display: block;
        }

        .menu-section {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #3c3c3c;
        }

        .menu-section:last-child {
            border-bottom: none;
        }

        .menu-section-title {
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .menu-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .menu-control:last-child {
            margin-bottom: 0;
        }

        .menu-control label {
            font-size: 0.75rem;
            color: #ccc;
            min-width: 60px;
        }

        .menu-control select,
        .menu-control input[type="number"] {
            flex: 1;
            padding: 0.25rem 0.5rem;
            border: 1px solid #3c3c3c;
            border-radius: 3px;
            font-size: 0.75rem;
            background: #3c3c3c;
            color: #fff;
        }

        .menu-control select:focus,
        .menu-control input:focus {
            outline: none;
            border-color: #4a90e2;
            background: #454545;
        }

        .menu-control .toolbar-badge {
            margin-left: 0;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Map container */
        #map {
            width: 100%;
            height: 100%;
            position: relative;
            background: #e5e5e5;
        }

        /* Info display */
        .info-display {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            line-height: 1.8;
            border: 2px solid #e9ecef;
        }

        .info-display strong {
            color: #495057;
            font-weight: 600;
        }

        /* Preview */
        #previewContainer {
            margin-top: 1rem;
            display: none;
        }

        #previewImage {
            width: 100%;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4a90e2;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Instructions */
        .instructions {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 1rem 1.25rem;
            border-radius: 8px;
            font-size: 0.85rem;
            line-height: 1.7;
            color: #1565c0;
            border: 2px solid rgba(74, 144, 226, 0.2);
            margin-bottom: 1rem;
        }

        .instructions strong {
            color: #0d47a1;
        }

        /* Helper text */
        .helper-text {
            color: #6c757d;
            font-size: 0.8rem;
            display: block;
            margin-top: 0.375rem;
            line-height: 1.4;
        }

        /* Input groups with number input */
        .input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .input-group input[type="range"] {
            flex: 1;
            margin: 0;
        }

        .input-group input[type="number"] {
            width: 70px;
            padding: 0.5rem;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.875rem;
            text-align: center;
        }

        .input-group input[type="number"]:focus {
            outline: none;
            border-color: #4a90e2;
        }

        /* Threshold display */
        .threshold-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .threshold-value {
            background: #4a90e2;
            color: white;
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.8rem;
        }

        /* Custom ratio indicator */
        .custom-ratio-badge {
            display: none;
            background: #ff9800;
            color: white;
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.75rem;
            margin-left: 0.5rem;
            animation: fadeIn 0.3s;
        }

        .custom-ratio-badge.active {
            display: inline-block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .ratio-label-wrapper {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        /* Square indicator */
        .square-indicator {
            display: none;
            background: #28a745;
            color: white;
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.75rem;
            margin-left: 0.5rem;
            animation: fadeIn 0.3s;
        }

        .square-indicator.active {
            display: inline-block;
        }

        /* Envelope warp button */
        .warp-button {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #6c757d;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .warp-button:hover {
            border-color: #495057;
            background: #f8f9fa;
        }

        .warp-button:active {
            transform: translateY(1px);
        }

        .warp-button.active {
            border-color: #007bff;
            background: #e7f3ff;
            color: #007bff;
        }

        .warp-value {
            background: #6c757d;
            color: white;
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .warp-button.active .warp-value {
            background: #007bff;
        }

        /* Range slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e9ecef;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #357abd;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #357abd;
            transform: scale(1.1);
        }

        /* AI Features Styling */
        .ai-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ai-suggestion {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-left: 3px solid #667eea;
            padding: 0.75rem;
            margin: 0.5rem 0;
            border-radius: 4px;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        .ai-suggestion strong {
            color: #667eea;
            display: block;
            margin-bottom: 0.25rem;
        }

        .ai-loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
        }

        #aiButton {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            transition: all 0.3s;
        }

        #aiButton:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        #aiButton:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .ai-description {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border: 2px solid rgba(102, 126, 234, 0.3);
            padding: 0.75rem;
            margin-top: 0.5rem;
            border-radius: 6px;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #333;
        }

        /* Large Preview Modal */
        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }

        .preview-modal.active {
            display: flex;
        }

        .preview-modal-content {
            background: #2a2a2a;
            border-radius: 8px;
            max-width: 95vw;
            max-height: 95vh;
            width: 1400px;
            display: flex;
            overflow: hidden;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            border: 1px solid #3a3a3a;
        }

        .preview-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #1e1e1e;
            padding: 20px;
            overflow: auto;
        }

        .preview-canvas-large {
            max-width: 100%;
            max-height: calc(95vh - 120px);
            border: 2px solid #444;
            background: #2a2a2a;
            cursor: grab;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .preview-canvas-large:active {
            cursor: grabbing;
        }

        .preview-right {
            width: 350px;
            padding: 20px;
            overflow-y: auto;
            background: #2a2a2a;
            color: #e0e0e0;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #3a3a3a;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
            color: #e0e0e0;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #888;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .close-modal:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .modal-control-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #333;
            border-radius: 6px;
            border-left: 3px solid #555;
        }

        .modal-control-section h3 {
            font-size: 1rem;
            margin: 0 0 10px 0;
            color: #e0e0e0;
            font-weight: 600;
        }

        .btn-modal-primary {
            width: 100%;
            padding: 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            transition: all 0.2s;
        }

        .btn-modal-primary:hover {
            background: #357abd;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .btn-modal-primary:active {
            transform: translateY(0);
        }

        /* Professional Editor Dark Theme Controls */
        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.875rem;
            color: #b0b0b0;
            font-weight: 500;
        }

        .control-group select,
        .control-group input[type="number"],
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px 10px;
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #4a90e2;
            background: #454545;
        }

        .control-group input[type="range"] {
            padding: 0;
            height: 6px;
            background: #3a3a3a;
            cursor: pointer;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4a90e2;
            cursor: pointer;
            border-radius: 50%;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4a90e2;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-group:hover {
            background: #3a3a3a;
        }

        .checkbox-group input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            flex: 1;
            color: #e0e0e0;
        }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            font-size: 0.75rem;
            border-radius: 3px;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge.new {
            background: #ff6b6b;
            color: white;
        }

        .badge.experimental {
            background: #ffa500;
            color: white;
        }

        .badge.ai {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        @media (max-width: 1024px) {
            .preview-modal-content {
                flex-direction: column;
            }

            .preview-right {
                width: 100%;
                max-height: 300px;
                overflow-y: auto;
            }

            .preview-left {
                max-height: 60vh;
            }

            .header-top {
                flex-wrap: wrap;
            }

            .menu-bar {
                width: 100%;
                justify-content: flex-start;
                margin-left: 0 !important;
                margin-top: 0.5rem;
            }
        }

        /* Tablet and small desktop */
        @media (max-width: 768px) {
            .header-top {
                padding: 0.5rem;
            }

            h1 {
                font-size: 0.95rem;
            }

            .search-container {
                max-width: 100%;
                min-width: 200px;
            }

            #searchInput {
                font-size: 0.85rem;
                padding: 0.4rem 0.6rem;
            }

            .menu-button,
            .toolbar-button {
                font-size: 0.75rem;
                padding: 0.4rem 0.6rem;
            }

            .menu-dropdown {
                min-width: 180px;
                font-size: 0.85rem;
            }

            .bbox-info {
                font-size: 0.7rem;
                padding: 0.5rem;
                max-width: 150px;
            }

            .preview-modal-content {
                padding: 1rem;
                max-height: 90vh;
            }

            .preview-right {
                max-height: 250px;
            }
        }

        /* Mobile phones */
        @media (max-width: 480px) {
            .header-top {
                padding: 0.5rem;
                gap: 0.5rem;
            }

            h1 {
                font-size: 0.9rem;
            }

            svg[width="32"] {
                width: 24px;
                height: 24px;
            }

            .search-container {
                width: 100%;
                max-width: 100%;
                min-width: unset;
                order: 3;
            }

            .menu-bar {
                width: 100%;
                gap: 0.35rem;
                margin-top: 0.5rem;
                order: 4;
            }

            .menu-button,
            .toolbar-button {
                font-size: 0.7rem;
                padding: 0.35rem 0.5rem;
                white-space: nowrap;
            }

            #helpBtn {
                width: 32px;
                height: 32px;
            }

            #helpBtn svg {
                width: 16px;
                height: 16px;
            }

            .menu-dropdown {
                left: auto;
                right: 0;
                min-width: 200px;
                max-width: calc(100vw - 1rem);
            }

            .menu-control {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.25rem;
            }

            .menu-control label {
                min-width: unset;
                font-size: 0.7rem;
            }

            .menu-control select,
            .menu-control input[type="number"] {
                width: 100%;
                font-size: 0.75rem;
            }

            .bbox-info {
                font-size: 0.65rem;
                padding: 0.4rem;
                max-width: 120px;
                top: 5px;
                right: 5px;
            }

            .preview-modal {
                padding: 0.5rem;
            }

            .preview-modal-content {
                padding: 0.75rem;
                max-height: 95vh;
                border-radius: 6px;
            }

            .preview-modal-content h2 {
                font-size: 1.1rem;
            }

            .preview-modal-content h3 {
                font-size: 0.95rem;
            }

            .preview-left {
                max-height: 50vh;
            }

            .preview-right {
                max-height: 200px;
                padding: 0.75rem;
            }

            .modal-control-section h3 {
                font-size: 0.9rem;
            }

            .control-group label {
                font-size: 0.8rem;
            }

            .btn-modal-primary {
                padding: 0.75rem;
                font-size: 0.9rem;
            }

            .close-modal {
                width: 32px;
                height: 32px;
                font-size: 1.5rem;
            }
        }

        /* Extra small phones */
        @media (max-width: 360px) {
            .header-top {
                padding: 0.4rem;
            }

            h1 {
                font-size: 0.85rem;
            }

            .menu-button,
            .toolbar-button {
                font-size: 0.65rem;
                padding: 0.3rem 0.4rem;
            }

            .bbox-info {
                font-size: 0.6rem;
                padding: 0.3rem;
                max-width: 100px;
            }

            .preview-modal-content {
                padding: 0.5rem;
            }

            .btn-modal-primary {
                padding: 0.65rem;
                font-size: 0.85rem;
            }
        }

        /* Touch-friendly enhancements */
        @media (hover: none) and (pointer: coarse) {
            .menu-button,
            .toolbar-button,
            .btn-modal-primary,
            .search-result-item {
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            #helpBtn {
                min-width: 44px;
                min-height: 44px;
            }

            .close-modal {
                min-width: 44px;
                min-height: 44px;
            }
        }

        /* Map controls styling */
        .leaflet-control-attribution {
            font-size: 0.7rem;
        }

        /* Bounding box info overlay */
        .bbox-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            max-width: 200px;
        }

        .bbox-info strong {
            display: block;
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <div class="header-top">
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <img src="maprdylogo.svg" width="28" height="24" alt="maprdy" style="display: block;">
                    <h1 style="margin: 0; font-size: 1.1rem; font-weight: 600; letter-spacing: 0.15em;">M A P R D Y</h1>
                </div>
                <div class="search-container">
                    <input 
                        type="text" 
                        id="searchInput" 
                        placeholder="Search location..."
                        autocomplete="off"
                    />
                    <div id="searchResults"></div>
                </div>
                
                <div class="menu-bar" style="margin-left: 1rem;">
                    <!-- Settings Menu -->
                    <div class="menu-item">
                        <button type="button" class="menu-button" id="settingsMenuBtn">
                            Settings â–¾
                        </button>
                        <div class="menu-dropdown" id="settingsMenu">
                            <div class="menu-section">
                                <div class="menu-section-title">Map Style</div>
                                <div class="menu-control">
                                    <label>Style</label>
                                    <select id="mapStyle">
                                        <option value="streets-v12" selected>Streets</option>
                                        <option value="light-v11">Light</option>
                                        <option value="dark-v11">Dark</option>
                                        <option value="outdoors-v12">Outdoors</option>
                                    </select>
                                </div>
                            </div>
                            <div class="menu-section">
                                <div class="menu-section-title">Output Settings</div>
                                <div class="menu-control">
                                    <label>Size</label>
                                    <select id="imageSize">
                                        <option value="800">800px</option>
                                        <option value="1000">1000px</option>
                                        <option value="1280">1280px</option>
                                        <option value="2000" selected>2000px</option>
                                        <option value="2560">2560px</option>
                                    </select>
                                </div>
                                <div class="menu-control">
                                    <span style="font-size: 0.65rem; color: #888;" id="actualSizeHelper">2000Ã—2000</span>
                                </div>
                            </div>
                            <div class="menu-section">
                                <div class="menu-section-title">Aspect Ratio</div>
                                <div class="menu-control">
                                    <label>Ratio</label>
                                    <select id="aspectRatio">
                                        <option value="1:1" selected>1:1</option>
                                        <option value="4:3">4:3</option>
                                        <option value="3:2">3:2</option>
                                        <option value="16:9">16:9</option>
                                        <option value="2:1">2:1</option>
                                        <option value="3:1">3:1</option>
                                        <option value="3:4">3:4</option>
                                        <option value="2:3">2:3</option>
                                        <option value="1:2">1:2</option>
                                    </select>
                                </div>
                                <div class="menu-control">
                                    <span class="toolbar-badge orange" id="customRatioBadge" style="display: none;">Custom</span>
                                    <span class="toolbar-badge green" id="squareIndicator" style="display: none;">Square</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tools Menu -->
                    <div class="menu-item">
                        <button type="button" class="menu-button" id="toolsMenuBtn">
                            Tools â–¾
                        </button>
                        <div class="menu-dropdown" id="toolsMenu">
                            <div class="menu-section">
                                <div class="menu-section-title">Selection</div>
                                <button type="button" class="toolbar-button" id="lockSelectionBtn" title="Lock Shape" style="width: 100%; margin-bottom: 0.5rem;">Lock Shape</button>
                                <button type="button" class="toolbar-button" id="lockZoomBtn" title="Lock Zoom" style="width: 100%; margin-bottom: 0.5rem;">Lock Zoom</button>
                                <button type="button" class="toolbar-button" id="clearSelectionBtn" title="Clear Selection" style="width: 100%; background: #dc3545; border-color: #dc3545;">Clear Selection</button>
                            </div>
                            <div class="menu-section">
                                <div class="menu-section-title">Dimensions</div>
                                <div class="menu-control">
                                    <label>Width</label>
                                    <input type="number" id="setWidth" placeholder="W" min="0.1" step="0.1" style="width: 70px;" title="Width" />
                                </div>
                                <div class="menu-control">
                                    <label>Height</label>
                                    <input type="number" id="setHeight" placeholder="H" min="0.1" step="0.1" style="width: 70px;" title="Height" />
                                </div>
                                <div class="menu-control">
                                    <label>Unit</label>
                                    <select id="dimensionUnit" style="width: 70px;">
                                        <option value="in" selected>in</option>
                                        <option value="mm">mm</option>
                                        <option value="cm">cm</option>
                                        <option value="m">m</option>
                                        <option value="km">km</option>
                                        <option value="ft">ft</option>
                                        <option value="mi">mi</option>
                                    </select>
                                </div>
                                <button type="button" class="toolbar-button" id="applyDimensionsBtn" title="Apply Dimensions" style="width: 100%; margin-top: 0.5rem;">Set Dimensions</button>
                            </div>
                        </div>
                    </div>

                    <!-- Primary Actions (Always Visible) -->
                    <div style="display: flex; gap: 0.5rem; align-items: center; margin-left: auto;">
                        <button type="button" class="menu-button" id="helpBtn" title="Help & Instructions" style="padding: 0.5rem; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                                <line x1="12" y1="17" x2="12.01" y2="17"></line>
                            </svg>
                        </button>
                        <button type="button" class="toolbar-button" id="aiButton" title="AI Assistant" style="padding: 0.65rem 1rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.95rem;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="4" y="4" width="16" height="16" rx="2"/>
                                <rect x="9" y="9" width="6" height="6"/>
                                <path d="M9 2V4M15 2V4M9 20V22M15 20V22M2 9H4M2 15H4M20 9H22M20 15H22" stroke-linecap="round"/>
                            </svg>
                            <span class="ai-badge">AI</span>
                        </button>
                        <button type="button" class="toolbar-button" id="generateBtn" style="background: #4a90e2; border-color: #4a90e2; padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 600;">
                            Process Map
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main content -->
        <div class="main-content">
            <!-- Map -->
            <div id="map">
                <div class="bbox-info" id="bboxInfo">
                    <strong>Selection Info</strong>
                    <div id="bboxCoords">--</div>
                    <div id="selectionInfo" style="margin-top: 0.5rem;">
                        <strong>Center:</strong> <span id="centerInfo">--</span><br>
                        <strong>Dimensions:</strong> <span id="dimensionsInfo">--</span><br>
                        <strong>Rotation:</strong> <span id="rotationInfo">0Â°</span>
                    </div>
                </div>
            </div>
            
            <!-- Hidden preview canvas -->
            <canvas id="previewCanvas" style="display: none;"></canvas>
        </div>
    </div>

    <!-- Large Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-modal-content">
            <div class="preview-left">
                <div style="position: relative;">
                    <canvas id="modalPreviewCanvas" class="preview-canvas-large"></canvas>
                    <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 0.5rem; border-radius: 4px; display: flex; gap: 0.5rem; align-items: center;">
                        <button id="zoomOut" style="padding: 0.25rem 0.5rem; background: #3c3c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">-</button>
                        <span id="zoomLevel" style="color: white; font-size: 0.875rem; min-width: 50px; text-align: center;">100%</span>
                        <button id="zoomIn" style="padding: 0.25rem 0.5rem; background: #3c3c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">+</button>
                        <button id="zoomReset" style="padding: 0.25rem 0.5rem; background: #3c3c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Reset</button>
                    </div>
                </div>
            </div>
            <div class="preview-right">
                <div class="modal-header">
                    <h2>ðŸŽ¨ Professional Editor</h2>
                    <button class="close-modal" id="closeModal">&times;</button>
                </div>

                <div style="background: #2a2a2a; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; border-left: 3px solid #4a90e2;">
                    <div style="font-size: 0.875rem; color: #e0e0e0;">
                        <strong>ðŸ’¡ Tip:</strong> All controls update the preview in real-time. Experiment to find the perfect settings for your engraving!
                    </div>
                </div>

                <div class="modal-control-section">
                    <h3>Output Settings</h3>
                    <div class="control-group">
                        <label for="modalImageSize">Output Size (px)</label>
                        <select id="modalImageSize">
                            <option value="800">800 x 800</option>
                            <option value="1000">1000 x 1000</option>
                            <option value="1280">1280 x 1280 (max standard)</option>
                            <option value="2000" selected>2000 x 2000 (retina)</option>
                            <option value="2560">2560 x 2560 (retina)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="modalAspectRatio">Aspect Ratio</label>
                        <select id="modalAspectRatio">
                            <option value="1:1" selected>1:1 Square</option>
                            <option value="4:3">4:3 Landscape</option>
                            <option value="3:2">3:2 Landscape</option>
                            <option value="16:9">16:9 Wide</option>
                            <option value="2:1">2:1 Extra Wide</option>
                            <option value="3:1">3:1 Ultra Wide</option>
                            <option value="4:1">4:1 Panoramic</option>
                            <option value="5:1">5:1 Super Panoramic</option>
                            <option value="3:4">3:4 Portrait</option>
                            <option value="2:3">2:3 Portrait</option>
                            <option value="1:2">1:2 Tall Portrait</option>
                        </select>
                    </div>
                </div>

                <div class="modal-control-section">
                    <h3>Processing Settings</h3>
                    <div class="control-group">
                        <label for="modalContrastThreshold">Contrast Threshold: <span id="modalThresholdValue">215</span></label>
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                            <input 
                                type="range" 
                                id="modalContrastThreshold" 
                                min="0" 
                                max="255" 
                                value="215"
                                style="flex: 1;"
                            />
                            <input 
                                type="number" 
                                id="modalContrastThresholdInput" 
                                min="0" 
                                max="255" 
                                value="215"
                                style="width: 60px; padding: 4px; border: 1px solid #ddd; border-radius: 4px;"
                            />
                        </div>
                        <small style="color: #666; font-size: 0.85em; display: block; margin-top: 4px;">Adjust in real-time to see changes</small>
                    </div>
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="modalEdgeDetection" />
                        <label for="modalEdgeDetection">Enable Edge Detection</label>
                    </div>
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="modalInvertColors" />
                        <label for="modalInvertColors">Invert Colors</label>
                    </div>
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="modalBlackText" />
                        <label for="modalBlackText">Black Text (force text to black)</label>
                    </div>
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="blackTextCheck" />
                        <label for="blackTextCheck">Black Text with White Box</label>
                    </div>
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="blackRoadsCheck" />
                        <label for="blackRoadsCheck">Black Roads (force roads solid)</label>
                    </div>
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="whiteWaterCheck" />
                        <label for="whiteWaterCheck">White Water</label>
                    </div>
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="thickenTextCheck" />
                        <label for="thickenTextCheck">Thicken Text & Lines <span class="toolbar-badge orange">NEW</span></label>
                    </div>
                    <div class="control-group" id="thickenAmountControl" style="display: none; margin-left: 1.5rem;">
                        <label for="thickenAmount">Thickness: <span id="thickenAmountValue">2</span>px</label>
                        <input type="range" id="thickenAmount" min="0.5" max="5" step="0.5" value="2" style="width: 100%;" />
                    </div>
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="removeFerryLinesCheck" />
                        <label for="removeFerryLinesCheck">Remove Ferry/Dashed Lines</label>
                    </div>
                </div>

                <div class="modal-control-section">
                    <h3>Current Selection Info</h3>
                    <div class="info-display" id="modalSelectionInfo">
                        <strong>Center:</strong> --<br>
                        <strong>Area:</strong> --
                    </div>
                    <div id="aiDescriptionContainer" style="display: none;">
                        <div class="ai-description" id="aiDescription"></div>
                    </div>
                </div>

                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <button class="btn-modal-primary" id="modalDownloadBtn" style="flex: 1;">Download PNG</button>
                    <button class="btn-modal-primary" id="copyToClipboardBtn" style="flex: 1; background: #28a745;">Copy Image</button>
                </div>
                <button class="btn-modal-primary" id="regenerateBtn" style="margin-top: 0.5rem; background: #6c757d;">Regenerate</button>
            </div>
        </div>
    </div>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <p>Processing image...</p>
        </div>
    </div>



    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // Dropdown menu functionality
        document.addEventListener('DOMContentLoaded', () => {
            const menus = ['settings', 'effects', 'tools'];
            
            menus.forEach(menuName => {
                const btn = document.getElementById(`${menuName}MenuBtn`);
                const dropdown = document.getElementById(`${menuName}Menu`);
                
                if (btn && dropdown) {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        
                        // Close other menus
                        menus.forEach(otherMenu => {
                            if (otherMenu !== menuName) {
                                const otherDropdown = document.getElementById(`${otherMenu}Menu`);
                                const otherBtn = document.getElementById(`${otherMenu}MenuBtn`);
                                if (otherDropdown && otherBtn) {
                                    otherDropdown.classList.remove('show');
                                    otherBtn.classList.remove('active');
                                }
                            }
                        });
                        
                        // Toggle current menu
                        dropdown.classList.toggle('show');
                        btn.classList.toggle('active');
                    });
                }
            });
            
            // Close menus when clicking outside
            document.addEventListener('click', (e) => {
                menus.forEach(menuName => {
                    const dropdown = document.getElementById(`${menuName}Menu`);
                    const btn = document.getElementById(`${menuName}MenuBtn`);
                    if (dropdown && btn && !dropdown.contains(e.target) && !btn.contains(e.target)) {
                        dropdown.classList.remove('show');
                        btn.classList.remove('active');
                    }
                });
            });

            // Help modal controls
            const helpBtn = document.getElementById('helpBtn');
            
            if (helpBtn) {
                helpBtn.addEventListener('click', () => {
                    showHelpModal();
                });
            }
            
            function showHelpModal() {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px; max-height: 90vh;">
                        <div class="modal-header">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                                </svg>
                                <h2>Help & Documentation</h2>
                            </div>
                            <button class="modal-close">&times;</button>
                        </div>
                        
                        <!-- Tab Navigation -->
                        <div style="display: flex; border-bottom: 1px solid #3a3a3a; background: #2a2a2a;">
                            <button class="help-tab active" data-tab="quickstart" style="flex: 1; padding: 12px 20px; background: none; border: none; color: #888; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; border-bottom: 2px solid transparent;">
                                Quick Start
                            </button>
                            <button class="help-tab" data-tab="keyboard" style="flex: 1; padding: 12px 20px; background: none; border: none; color: #888; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; border-bottom: 2px solid transparent;">
                                Keyboard Shortcuts
                            </button>
                            <button class="help-tab" data-tab="features" style="flex: 1; padding: 12px 20px; background: none; border: none; color: #888; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; border-bottom: 2px solid transparent;">
                                Features Guide
                            </button>
                            <button class="help-tab" data-tab="tips" style="flex: 1; padding: 12px 20px; background: none; border: none; color: #888; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; border-bottom: 2px solid transparent;">
                                Pro Tips
                            </button>
                        </div>
                        
                        <div class="modal-body" style="padding: 0;">
                            <!-- Quick Start Tab -->
                            <div class="help-content active" data-content="quickstart" style="padding: 24px;">
                                <h3 style="color: #4a90e2; margin: 0 0 20px 0; font-size: 18px;">Getting Started with mapit</h3>
                                
                                <div class="help-step">
                                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                        <div style="background: #4a90e2; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; flex-shrink: 0;">1</div>
                                        <h4 style="margin: 0; color: #e0e0e0; font-size: 16px;">Find Your Location</h4>
                                    </div>
                                    <div style="padding-left: 44px; color: #b0b0b0; line-height: 1.6;">
                                        <p style="margin-bottom: 8px;"><strong style="color: #e0e0e0;">Search:</strong> Type an address or landmark in the search bar</p>
                                        <p style="margin-bottom: 0;"><strong style="color: #e0e0e0;">Navigate:</strong> Click and drag to pan, scroll to zoom</p>
                                    </div>
                                </div>
                                
                                <div class="help-step" style="margin-top: 24px;">
                                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                        <div style="background: #4a90e2; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; flex-shrink: 0;">2</div>
                                        <h4 style="margin: 0; color: #e0e0e0; font-size: 16px;">Adjust Selection Area</h4>
                                    </div>
                                    <div style="padding-left: 44px; color: #b0b0b0; line-height: 1.6;">
                                        <p style="margin-bottom: 8px;">The blue rectangle shows what will be captured.</p>
                                        <div style="background: #3a3a3a; padding: 12px; border-radius: 4px; border-left: 3px solid #4a90e2;">
                                            <strong style="color: #4a90e2;">Hold SPACEBAR:</strong>
                                            <ul style="margin: 8px 0 0 20px; padding: 0;">
                                                <li>Drag to move selection</li>
                                                <li>Scroll to rotate</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="help-step" style="margin-top: 24px;">
                                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                        <div style="background: #4a90e2; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; flex-shrink: 0;">3</div>
                                        <h4 style="margin: 0; color: #e0e0e0; font-size: 16px;">Configure Settings</h4>
                                    </div>
                                    <div style="padding-left: 44px; color: #b0b0b0; line-height: 1.6;">
                                        <p style="margin-bottom: 8px;">Customize your map output:</p>
                                        <ul style="margin: 0 0 0 20px; padding: 0; line-height: 1.8;">
                                            <li><strong style="color: #e0e0e0;">Settings:</strong> Style, size, aspect ratio, contrast</li>
                                            <li><strong style="color: #e0e0e0;">Effects:</strong> Laser mode, edge detection, invert</li>
                                            <li><strong style="color: #e0e0e0;">Tools:</strong> Lock selection, dimensions, clear</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div class="help-step" style="margin-top: 24px;">
                                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                        <div style="background: #4a90e2; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; flex-shrink: 0;">4</div>
                                        <h4 style="margin: 0; color: #e0e0e0; font-size: 16px;">Process & Edit</h4>
                                    </div>
                                    <div style="padding-left: 44px; color: #b0b0b0; line-height: 1.6;">
                                        <p style="margin: 0;">Click <strong style="color: #4a90e2;">Process Map</strong> to generate your image. The professional editor will open with advanced controls for fine-tuning.</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Keyboard Shortcuts Tab -->
                            <div class="help-content" data-content="keyboard" style="padding: 24px; display: none;">
                                <h3 style="color: #4a90e2; margin: 0 0 20px 0; font-size: 18px;">Keyboard Shortcuts</h3>
                                
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                                    <div>
                                        <h4 style="color: #4a90e2; font-size: 14px; margin: 0 0 12px 0; text-transform: uppercase; letter-spacing: 0.5px;">Map Navigation</h4>
                                        <div class="shortcut-list">
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Drag selection</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">SPACE + Drag</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                                                <span style="color: #b0b0b0;">Rotate selection</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">SPACE + Scroll</kbd>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <h4 style="color: #4a90e2; font-size: 14px; margin: 0 0 12px 0; text-transform: uppercase; letter-spacing: 0.5px;">File Operations</h4>
                                        <div class="shortcut-list">
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Save as PNG</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+S</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Save as JPG</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+Shift+S</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Export settings</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+E</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                                                <span style="color: #b0b0b0;">Import settings</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+I</kbd>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <h4 style="color: #4a90e2; font-size: 14px; margin: 0 0 12px 0; text-transform: uppercase; letter-spacing: 0.5px;">Edit</h4>
                                        <div class="shortcut-list">
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Undo</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+Z</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Redo</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+Y</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Duplicate settings</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+D</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                                                <span style="color: #b0b0b0;">Preferences</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+,</kbd>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <h4 style="color: #4a90e2; font-size: 14px; margin: 0 0 12px 0; text-transform: uppercase; letter-spacing: 0.5px;">View</h4>
                                        <div class="shortcut-list">
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Toggle rulers</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+R</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Toggle grid</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+G</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Toggle guides</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+;</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Toggle toolbar</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+H</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Actual size (100%)</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+1</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Fit to window</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Ctrl+0</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Zoom in</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">+</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Zoom out</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">-</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Pan canvas</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Space + Drag</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                                                <span style="color: #b0b0b0;">Fullscreen</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">F11</kbd>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <h4 style="color: #4a90e2; font-size: 14px; margin: 0 0 12px 0; text-transform: uppercase; letter-spacing: 0.5px;">Adjustments & Other</h4>
                                        <div class="shortcut-list">
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Increase contrast</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">â†‘</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Decrease contrast</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">â†“</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Clear all guides</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Delete</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #3a3a3a;">
                                                <span style="color: #b0b0b0;">Close modal/cancel</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">Escape</kbd>
                                            </div>
                                            <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                                                <span style="color: #b0b0b0;">Show help</span>
                                                <kbd style="background: #1e1e1e; padding: 4px 8px; border-radius: 3px; font-family: monospace; color: #4a90e2; font-size: 12px;">F1</kbd>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Features Guide Tab -->
                            <div class="help-content" data-content="features" style="padding: 24px; display: none;">
                                <h3 style="color: #4a90e2; margin: 0 0 20px 0; font-size: 18px;">Feature Guide</h3>
                                
                                <div class="feature-section" style="margin-bottom: 24px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <circle cx="12" cy="12" r="3"/>
                                            <path d="M12 1V3M12 21V23M4.22 4.22L5.64 5.64M18.36 18.36L19.78 19.78M1 12H3M21 12H23M4.22 19.78L5.64 18.36M18.36 5.64L19.78 4.22"/>
                                        </svg>
                                        Contrast & Threshold
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0 0 8px 0; line-height: 1.6;">Controls how light/dark areas are separated. Lower values = more detail, higher = cleaner lines. Ideal range: 180-220 for most maps.</p>
                                </div>
                                
                                <div class="feature-section" style="margin-bottom: 24px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <rect x="3" y="3" width="7" height="7"/>
                                            <rect x="14" y="3" width="7" height="7"/>
                                            <rect x="14" y="14" width="7" height="7"/>
                                            <rect x="3" y="14" width="7" height="7"/>
                                        </svg>
                                        Edge Detection
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0 0 8px 0; line-height: 1.6;">Highlights boundaries and outlines. Great for artistic effects or tracing paths. Works best with medium contrast settings.</p>
                                </div>
                                
                                <div class="feature-section" style="margin-bottom: 24px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                                        </svg>
                                        Laser Mode
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0 0 8px 0; line-height: 1.6;">Converts to pure black on white - perfect for laser engraving. Removes grays for clean, engraveable output. Combine with "Black Roads" and "Black Text" for best results.</p>
                                </div>
                                
                                <div class="feature-section" style="margin-bottom: 24px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <path d="M12 2L2 7L12 12L22 7L12 2Z"/>
                                            <path d="M2 17L12 22L22 17"/>
                                            <path d="M2 12L12 17L22 12"/>
                                        </svg>
                                        Layers
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0 0 8px 0; line-height: 1.6;">Toggle between processed and original map views. Adjust opacity to compare before/after. Perfect for fine-tuning your settings.</p>
                                </div>
                                
                                <div class="feature-section" style="margin-bottom: 24px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                                            <line x1="3" y1="9" x2="21" y2="9"/>
                                            <line x1="9" y1="21" x2="9" y2="3"/>
                                        </svg>
                                        Rulers & Grid
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0 0 8px 0; line-height: 1.6;">Professional rulers with customizable units (pixels, inches, cm). Toggle grid overlay with configurable spacing and opacity. Perfect for precise measurements and alignment. Use Ctrl+R for rulers, Ctrl+G for grid.</p>
                                </div>
                                
                                <div class="feature-section" style="margin-bottom: 24px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <path d="M3 3L21 21M3 21L21 3"/>
                                        </svg>
                                        Draggable Guides
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0 0 8px 0; line-height: 1.6;">Drag guides from rulers to create horizontal and vertical reference lines. Perfect for alignment and composition. Toggle with Ctrl+; or clear all with Delete key. Guides glow cyan for easy visibility.</p>
                                </div>
                                
                                <div class="feature-section" style="margin-bottom: 24px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <rect x="3" y="3" width="7" height="7" rx="1"/>
                                            <rect x="14" y="3" width="7" height="7" rx="1"/>
                                            <rect x="14" y="14" width="7" height="7" rx="1"/>
                                            <rect x="3" y="14" width="7" height="7" rx="1"/>
                                        </svg>
                                        Quick Presets
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0 0 8px 0; line-height: 1.6;">One-click configurations for common use cases: Laser (optimized for engraving), Print (high contrast), Detailed (preserves fine features), and Clean (minimal aesthetic). Instantly apply professionally tuned settings.</p>
                                </div>
                                
                                <div class="feature-section" style="margin-bottom: 24px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <circle cx="12" cy="12" r="3"/>
                                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                                        </svg>
                                        Preferences
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0 0 8px 0; line-height: 1.6;">Customize grid spacing, ruler units, display intervals, and default settings. All preferences are saved locally so your workspace stays configured exactly how you like it. Access with Ctrl+,</p>
                                </div>
                                
                                <div class="feature-section">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                            <rect x="4" y="4" width="16" height="16" rx="2"/>
                                            <rect x="9" y="9" width="6" height="6"/>
                                            <path d="M9 2V4M15 2V4M9 20V22M15 20V22M2 9H4M2 15H4M20 9H22M20 15H22" stroke-linecap="round"/>
                                        </svg>
                                        AI Assistant
                                    </h4>
                                    <p style="color: #b0b0b0; margin: 0; line-height: 1.6;">Get intelligent recommendations for style, size, and settings based on your intended use. Tell the AI what you're making (wall art, laser engraving, etc.) for optimized suggestions.</p>
                                </div>
                            </div>
                            
                            <!-- Pro Tips Tab -->
                            <div class="help-content" data-content="tips" style="padding: 24px; display: none;">
                                <h3 style="color: #4a90e2; margin: 0 0 20px 0; font-size: 18px;">Pro Tips & Best Practices</h3>
                                
                                <div style="background: #3a3a3a; padding: 16px; border-radius: 4px; border-left: 4px solid #27ae60; margin-bottom: 16px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#27ae60" stroke-width="2">
                                            <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                                        </svg>
                                        For Laser Engraving
                                    </h4>
                                    <ul style="margin: 0; padding-left: 20px; color: #b0b0b0; line-height: 1.8;">
                                        <li>Enable <strong style="color: #e0e0e0;">Laser Mode</strong></li>
                                        <li>Check <strong style="color: #e0e0e0;">Black Text with Box</strong></li>
                                        <li>Enable <strong style="color: #e0e0e0;">Black Roads</strong></li>
                                        <li>Set contrast to 200-220</li>
                                        <li>Use <strong style="color: #e0e0e0;">Thicken Text</strong> (1-2px) for small maps</li>
                                    </ul>
                                </div>
                                
                                <div style="background: #3a3a3a; padding: 16px; border-radius: 4px; border-left: 4px solid #3498db; margin-bottom: 16px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#3498db" stroke-width="2">
                                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                                            <circle cx="8.5" cy="8.5" r="1.5"/>
                                            <path d="M21 15L16 10L5 21"/>
                                        </svg>
                                        For Wall Art / Posters
                                    </h4>
                                    <ul style="margin: 0; padding-left: 20px; color: #b0b0b0; line-height: 1.8;">
                                        <li>Keep contrast lower (160-180) for more detail</li>
                                        <li>Try <strong style="color: #e0e0e0;">White Water</strong> for coastal areas</li>
                                        <li>Use larger output sizes (2560+)</li>
                                        <li>Experiment with <strong style="color: #e0e0e0;">Invert</strong> for dark backgrounds</li>
                                    </ul>
                                </div>
                                
                                <div style="background: #3a3a3a; padding: 16px; border-radius: 4px; border-left: 4px solid #e74c3c; margin-bottom: 16px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#e74c3c" stroke-width="2">
                                            <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
                                        </svg>
                                        Performance Tips
                                    </h4>
                                    <ul style="margin: 0; padding-left: 20px; color: #b0b0b0; line-height: 1.8;">
                                        <li>Start with smaller sizes (1280) to test settings quickly</li>
                                        <li>Use <strong style="color: #e0e0e0;">Ctrl+Z</strong> to undo changes instantly</li>
                                        <li>Save your favorite settings using browser bookmarks</li>
                                        <li>Lock selection (Tools menu) to prevent accidental moves</li>
                                    </ul>
                                </div>
                                
                                <div style="background: #3a3a3a; padding: 16px; border-radius: 4px; border-left: 4px solid #f39c12; margin-bottom: 16px;">
                                    <h4 style="color: #e0e0e0; margin: 0 0 12px 0; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#f39c12" stroke-width="2">
                                            <circle cx="12" cy="12" r="10"/>
                                            <polygon points="10 8 16 12 10 16 10 8"/>
                                        </svg>
                                        Advanced Techniques
                                    </h4>
                                    <ul style="margin: 0; padding-left: 20px; color: #b0b0b0; line-height: 1.8;">
                                        <li><strong style="color: #e0e0e0;">Rotation:</strong> Hold SPACEBAR + scroll to rotate selection</li>
                                        <li><strong style="color: #e0e0e0;">Coastlines:</strong> Enable "Thicken Coastlines" for island maps</li>
                                        <li><strong style="color: #e0e0e0;">Drag-and-drop:</strong> Reorder editor sections by dragging headers</li>
                                        <li><strong style="color: #e0e0e0;">Layers:</strong> Use opacity slider to fade original map overlay</li>
                                        <li><strong style="color: #e0e0e0;">Batch work:</strong> Process multiple areas, compare in separate tabs</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Tab switching
                const tabs = modal.querySelectorAll('.help-tab');
                const contents = modal.querySelectorAll('.help-content');
                
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const targetTab = tab.dataset.tab;
                        
                        // Update tabs
                        tabs.forEach(t => {
                            t.classList.remove('active');
                            t.style.color = '#888';
                            t.style.borderBottomColor = 'transparent';
                        });
                        tab.classList.add('active');
                        tab.style.color = '#e0e0e0';
                        tab.style.borderBottomColor = '#4a90e2';
                        
                        // Update content
                        contents.forEach(c => {
                            c.classList.remove('active');
                            c.style.display = 'none';
                        });
                        const targetContent = modal.querySelector(`[data-content="${targetTab}"]`);
                        if (targetContent) {
                            targetContent.classList.add('active');
                            targetContent.style.display = 'block';
                        }
                    });
                });
                
                // Set initial active tab styling
                const activeTab = modal.querySelector('.help-tab.active');
                if (activeTab) {
                    activeTab.style.color = '#e0e0e0';
                    activeTab.style.borderBottomColor = '#4a90e2';
                }
                
                // Close handlers
                modal.querySelector('.modal-close').addEventListener('click', () => modal.remove());
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.remove();
                });
                
                // ESC key to close
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escHandler);
                    }
                };
                document.addEventListener('keydown', escHandler);
            }
        });

        // Configuration
        const CONFIG = {
            defaultCenter: [40.7128, -74.0060], // New York City
            defaultZoom: 13,
            defaultBounds: {
                north: 40.7628,
                south: 40.6628,
                east: -73.9560,
                west: -74.0560
            }
        };

        // Global variables
        let map;
        let boundingBox;
        let processedImageData = null;
        let originalImageElement = null;
        let originalImageData = null; // Unprocessed original image for editor
        let selectedLocationName = 'New York City, New York, United States'; // Store selected location name
        let currentEnvelopeWarp = 0; // 0, 1, 2, 3, 4 for Off, -1%, -2%, -3%, -4%
        let isDragModeEnabled = false; // Keyboard control for dragging
        let rotationAngle = 0; // Rotation angle in degrees
        let rotationOverlay = null; // Visual indicator for rotation
        let baseLatDiff = 0; // Store unrotated dimensions
        let baseLngDiff = 0;
        let isSelectionLocked = false; // Lock to prevent resizing
        let lastZoomLevel = 13; // Track zoom level for scaling
        let isZoomLocked = false; // Lock to prevent zoom scaling
        let edgeDetectionEnabled = false; // Edge detection state
        let invertColorsEnabled = false; // Invert colors state
        let laserMode = false; // Laser mode state
        let blackTextEnabled = false; // Black text preservation state
        let blackRoadsEnabled = false; // Black roads forcing state
        let whiteWaterEnabled = false; // White water forcing state
        let previewZoom = 1; // Preview modal zoom level
        let previewPanX = 0; // Preview modal pan X
        let previewPanY = 0; // Preview modal pan Y
        let isPanning = false; // Preview modal panning state
        let panStartX = 0;
        let panStartY = 0;
        let previewBaseImage = null; // Store base image for redrawing
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // Don't capture spacebar if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                isDragModeEnabled = true;
                document.body.style.cursor = 'grab';
                if (boundingBox) {
                    boundingBox.setStyle({ fillColor: '#4a90e2', fillOpacity: 0.3 });
                }
                // Disable map dragging and scrollWheelZoom when space is held
                if (map) {
                    map.dragging.disable();
                    map.scrollWheelZoom.disable();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            // Don't capture spacebar if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            if (e.code === 'Space') {
                isDragModeEnabled = false;
                document.body.style.cursor = 'default';
                if (boundingBox) {
                    boundingBox.setStyle({ fillColor: '#4a90e2', fillOpacity: 0.1 });
                }
                // Re-enable map dragging and scrollWheelZoom
                if (map) {
                    map.dragging.enable();
                    map.scrollWheelZoom.enable();
                }
                // Hide rotation overlay
                if (rotationOverlay) {
                    rotationOverlay.style.display = 'none';
                }
            }
        });

        // Wheel rotation control (only when SPACE is held)
        document.addEventListener('wheel', (e) => {
            if (!isDragModeEnabled || !boundingBox) return;
            
            e.preventDefault();
            
            // Adjust rotation angle (each wheel tick = 5 degrees)
            const delta = e.deltaY > 0 ? 5 : -5;
            rotationAngle = (rotationAngle + delta) % 360;
            
            // Update rotation overlay
            updateRotationOverlay();
            
            // Update bounding box visual (convert to polygon for rotation)
            updateRotatedBoundingBox();
        }, { passive: false });

        function updateRotationOverlay() {
            if (!rotationOverlay) {
                rotationOverlay = document.createElement('div');
                rotationOverlay.style.position = 'fixed';
                rotationOverlay.style.top = '50%';
                rotationOverlay.style.left = '50%';
                rotationOverlay.style.transform = 'translate(-50%, -50%)';
                rotationOverlay.style.background = 'rgba(0, 0, 0, 0.8)';
                rotationOverlay.style.color = 'white';
                rotationOverlay.style.padding = '15px 25px';
                rotationOverlay.style.borderRadius = '8px';
                rotationOverlay.style.fontSize = '18px';
                rotationOverlay.style.fontWeight = 'bold';
                rotationOverlay.style.zIndex = '10001';
                rotationOverlay.style.pointerEvents = 'none';
                document.body.appendChild(rotationOverlay);
            }
            
            rotationOverlay.textContent = `Rotation: ${rotationAngle}Â°`;
            rotationOverlay.style.display = 'block';
        }

        function updateRotatedBoundingBox() {
            const center = boundingBox.getBounds().getCenter();
            
            // Use stored base dimensions for rotation
            const angleRad = (rotationAngle * Math.PI) / 180;
            
            // Define corners relative to center using base dimensions (unrotated)
            const baseCorners = [
                { dlat: baseLatDiff, dlng: -baseLngDiff },  // NW
                { dlat: baseLatDiff, dlng: baseLngDiff },   // NE
                { dlat: -baseLatDiff, dlng: baseLngDiff },  // SE
                { dlat: -baseLatDiff, dlng: -baseLngDiff }  // SW
            ];
            
            // Rotate each corner around center
            const rotatedCorners = baseCorners.map(({ dlat, dlng }) => {
                const rotatedLng = dlng * Math.cos(angleRad) - dlat * Math.sin(angleRad);
                const rotatedLat = dlng * Math.sin(angleRad) + dlat * Math.cos(angleRad);
                
                return [center.lat + rotatedLat, center.lng + rotatedLng];
            });
            
            // Update bounding box to show rotation visually
            boundingBox.setLatLngs(rotatedCorners);
            
            // Update corner markers
            if (window.updateCorners) {
                window.updateCorners();
            }
        }

        // Initialize map
        function initMap() {
            map = L.map('map', {
                center: CONFIG.defaultCenter,
                zoom: CONFIG.defaultZoom,
                zoomControl: true,
                scrollWheelZoom: true
            });

            // Add tile layer (using OpenStreetMap for preview)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);

            // Create initial bounding box
            createBoundingBox();

            // Add click handler for map
            map.on('click', function(e) {
                const bounds = boundingBox.getBounds();
                const center = e.latlng;
                const latDiff = (bounds.getNorth() - bounds.getSouth()) / 2;
                const lngDiff = (bounds.getEast() - bounds.getWest()) / 2;
                
                const newBounds = L.latLngBounds(
                    [center.lat - latDiff, center.lng - lngDiff],
                    [center.lat + latDiff, center.lng + lngDiff]
                );
                
                boundingBox.setBounds(newBounds);
                updateBoundingBoxInfo();
            });
        }

        // Create bounding box as polygon (to support rotation)
        function createBoundingBox() {
            const bounds = L.latLngBounds(
                [CONFIG.defaultBounds.south, CONFIG.defaultBounds.west],
                [CONFIG.defaultBounds.north, CONFIG.defaultBounds.east]
            );

            // Store base dimensions (unrotated)
            baseLatDiff = (bounds.getNorth() - bounds.getSouth()) / 2;
            baseLngDiff = (bounds.getEast() - bounds.getWest()) / 2;

            // Create as polygon with 4 corners
            const corners = [
                [bounds.getNorth(), bounds.getWest()], // NW
                [bounds.getNorth(), bounds.getEast()], // NE
                [bounds.getSouth(), bounds.getEast()], // SE
                [bounds.getSouth(), bounds.getWest()]  // SW
            ];

            boundingBox = L.polygon(corners, {
                color: '#4a90e2',
                weight: 3,
                fillOpacity: 0.1
            }).addTo(map);

            // Make it draggable and editable
            makeBoundingBoxEditable();

            // Update info on changes
            map.on('moveend', updateBoundingBoxInfo);
            
            // Scale bounding box on zoom
            map.on('zoomend', function() {
                const currentZoom = map.getZoom();
                const zoomDelta = currentZoom - lastZoomLevel;
                
                // Only scale if zoom lock is disabled
                if (zoomDelta !== 0 && !isZoomLocked) {
                    // Calculate scale factor (each zoom level doubles/halves the scale)
                    const scaleFactor = Math.pow(2, -zoomDelta);
                    
                    const bounds = boundingBox.getBounds();
                    const center = bounds.getCenter();
                    
                    // Scale the base dimensions
                    baseLatDiff *= scaleFactor;
                    baseLngDiff *= scaleFactor;
                    
                    // Update corners based on new scaled dimensions
                    if (rotationAngle === 0) {
                        // No rotation - simple rectangle
                        const newCorners = [
                            [center.lat - baseLatDiff, center.lng - baseLngDiff],
                            [center.lat - baseLatDiff, center.lng + baseLngDiff],
                            [center.lat + baseLatDiff, center.lng + baseLngDiff],
                            [center.lat + baseLatDiff, center.lng - baseLngDiff]
                        ];
                        boundingBox.setLatLngs(newCorners);
                    } else {
                        // Has rotation - maintain rotation
                        updateRotatedBoundingBox();
                    }
                    
                    updateCorners();
                    updateBoundingBoxInfo();
                }
                
                lastZoomLevel = currentZoom;
            });

            updateBoundingBoxInfo();
        }

        // Make bounding box editable with drag handles
        function makeBoundingBoxEditable() {
            let isDragging = false;
            let dragCorner = null;
            let startLatLng = null;
            let startBounds = null;

            // Add corner and edge markers for resizing
            const corners = [];
            const edgeMarkers = [];
            
            // Make updateCorners accessible globally
            window.updateCorners = updateCorners;

            function updateCorners() {
                // Remove old markers
                corners.forEach(marker => map.removeLayer(marker));
                corners.length = 0;
                edgeMarkers.forEach(marker => map.removeLayer(marker));
                edgeMarkers.length = 0;

                // Get polygon coordinates
                const latlngs = boundingBox.getLatLngs()[0];
                
                // Add corner markers
                latlngs.forEach((pos, idx) => {
                    const marker = L.circleMarker(pos, {
                        radius: 8,
                        color: isSelectionLocked ? '#999' : '#4a90e2',
                        fillColor: isSelectionLocked ? '#ccc' : '#fff',
                        fillOpacity: 1,
                        weight: 2
                    }).addTo(map);

                    marker.on('mousedown', (e) => {
                        // Allow corner dragging anytime unless locked
                        if (isSelectionLocked) return;
                        
                        isDragging = true;
                        dragCorner = idx;
                        startLatLng = e.latlng;
                        const currentLatLngs = boundingBox.getLatLngs()[0];
                        startBounds = {
                            corners: currentLatLngs.map(ll => [ll.lat, ll.lng])
                        };
                        L.DomEvent.stopPropagation(e);
                    });

                    corners.push(marker);
                });
                
                // Add edge midpoint markers
                for (let i = 0; i < latlngs.length; i++) {
                    const p1 = latlngs[i];
                    const p2 = latlngs[(i + 1) % latlngs.length];
                    const midLat = (p1.lat + p2.lat) / 2;
                    const midLng = (p1.lng + p2.lng) / 2;
                    
                    const edgeMarker = L.circleMarker([midLat, midLng], {
                        radius: 6,
                        color: isSelectionLocked ? '#999' : '#28a745',
                        fillColor: isSelectionLocked ? '#ccc' : '#fff',
                        fillOpacity: 1,
                        weight: 2
                    }).addTo(map);
                    
                    edgeMarker.on('mousedown', (e) => {
                        if (isSelectionLocked) return;
                        
                        isDragging = true;
                        dragCorner = `edge-${i}`;
                        startLatLng = e.latlng;
                        const currentLatLngs = boundingBox.getLatLngs()[0];
                        startBounds = {
                            corners: currentLatLngs.map(ll => [ll.lat, ll.lng]),
                            edgeIndex: i
                        };
                        L.DomEvent.stopPropagation(e);
                    });
                    
                    edgeMarkers.push(edgeMarker);
                }
            }

            updateCorners();

            // Handle dragging the entire box (only when SPACE is held)
            boundingBox.on('mousedown', (e) => {
                if (!isDragModeEnabled || dragCorner !== null) return;
                isDragging = true;
                startLatLng = e.latlng;
                const currentLatLngs = boundingBox.getLatLngs()[0];
                startBounds = {
                    corners: currentLatLngs.map(ll => [ll.lat, ll.lng])
                };
                document.body.style.cursor = 'grabbing';
                map.dragging.disable(); // Ensure map drag is disabled
                L.DomEvent.preventDefault(e);
                L.DomEvent.stopPropagation(e);
            });

            // Also handle drag on map when space is held and mouse is over bounding box
            map.on('mousedown', (e) => {
                if (!isDragModeEnabled) return;
                
                // Check if click is within bounding box
                const bounds = boundingBox.getBounds();
                if (bounds.contains(e.latlng)) {
                    isDragging = true;
                    startLatLng = e.latlng;
                    const currentLatLngs = boundingBox.getLatLngs()[0];
                    startBounds = {
                        corners: currentLatLngs.map(ll => [ll.lat, ll.lng])
                    };
                    document.body.style.cursor = 'grabbing';
                    map.dragging.disable();
                    L.DomEvent.preventDefault(e);
                    L.DomEvent.stopPropagation(e);
                }
            });

            map.on('mousemove', (e) => {
                if (!isDragging) return;

                if (dragCorner !== null) {
                    // Check if dragging an edge or a corner
                    if (typeof dragCorner === 'string' && dragCorner.startsWith('edge-')) {
                        // Dragging an edge - move both corners of that edge
                        const edgeIndex = parseInt(dragCorner.split('-')[1]);
                        const newCorners = [...startBounds.corners];
                        
                        // Calculate movement delta
                        const startMidLat = (startBounds.corners[edgeIndex][0] + startBounds.corners[(edgeIndex + 1) % 4][0]) / 2;
                        const startMidLng = (startBounds.corners[edgeIndex][1] + startBounds.corners[(edgeIndex + 1) % 4][1]) / 2;
                        const latDiff = e.latlng.lat - startMidLat;
                        const lngDiff = e.latlng.lng - startMidLng;
                        
                        // Move both corners of this edge
                        newCorners[edgeIndex] = [
                            startBounds.corners[edgeIndex][0] + latDiff,
                            startBounds.corners[edgeIndex][1] + lngDiff
                        ];
                        newCorners[(edgeIndex + 1) % 4] = [
                            startBounds.corners[(edgeIndex + 1) % 4][0] + latDiff,
                            startBounds.corners[(edgeIndex + 1) % 4][1] + lngDiff
                        ];
                        
                        boundingBox.setLatLngs(newCorners);
                        
                        // Recalculate base dimensions from new corners
                        const bounds = boundingBox.getBounds();
                        const center = bounds.getCenter();
                        baseLatDiff = (bounds.getNorth() - bounds.getSouth()) / 2;
                        baseLngDiff = (bounds.getEast() - bounds.getWest()) / 2;
                        
                        // Reset rotation when manually resizing
                        rotationAngle = 0;
                        
                        // Show custom ratio indicator
                        document.getElementById('customRatioBadge').classList.add('active');
                    } else {
                        // Dragging a corner - resize by moving that corner
                        const newCorners = [...startBounds.corners];
                        newCorners[dragCorner] = [e.latlng.lat, e.latlng.lng];
                        
                        boundingBox.setLatLngs(newCorners);
                        
                        // Recalculate base dimensions from new corners
                        const bounds = boundingBox.getBounds();
                        const center = bounds.getCenter();
                        baseLatDiff = (bounds.getNorth() - bounds.getSouth()) / 2;
                        baseLngDiff = (bounds.getEast() - bounds.getWest()) / 2;
                        
                        // Reset rotation when manually resizing
                        rotationAngle = 0;
                        
                        // Show custom ratio indicator
                        document.getElementById('customRatioBadge').classList.add('active');
                    }
                } else {
                    // Move entire box
                    const latDiff = e.latlng.lat - startLatLng.lat;
                    const lngDiff = e.latlng.lng - startLatLng.lng;

                    const newCorners = startBounds.corners.map(([lat, lng]) => [
                        lat + latDiff,
                        lng + lngDiff
                    ]);

                    boundingBox.setLatLngs(newCorners);
                }

                updateCorners();
                updateBoundingBoxInfo();
                
                // Check if selection is square after dragging
                if (dragCorner !== null) {
                    checkIfSquare();
                }
            });

            map.on('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    dragCorner = null;
                    document.body.style.cursor = isDragModeEnabled ? 'grab' : 'default';
                    updateBoundingBoxInfo();
                }
            });

            // Update corners when bounds change
            boundingBox.on('remove', () => {
                corners.forEach(marker => map.removeLayer(marker));
                edgeMarkers.forEach(marker => map.removeLayer(marker));
            });
        }

        // Update bounding box info display
        function updateBoundingBoxInfo() {
            const bounds = boundingBox.getBounds();
            const center = bounds.getCenter();
            
            // Update map info overlay
            const coords = `
                N: ${bounds.getNorth().toFixed(4)}<br>
                S: ${bounds.getSouth().toFixed(4)}<br>
                E: ${bounds.getEast().toFixed(4)}<br>
                W: ${bounds.getWest().toFixed(4)}
            `;
            document.getElementById('bboxCoords').innerHTML = coords;

            // Calculate dimensions in kilometers
            const latDiff = bounds.getNorth() - bounds.getSouth();
            const lngDiff = bounds.getEast() - bounds.getWest();
            const heightKm = latDiff * 111.32;
            const widthKm = lngDiff * 111.32 * Math.cos(center.lat * Math.PI / 180);
            const area = heightKm * widthKm;
            
            // Convert to selected unit
            const unit = document.getElementById('dimensionUnit').value;
            const { width, height, unitLabel } = convertDimensions(widthKm, heightKm, unit);
            
            // Update map overlay
            document.getElementById('bboxCoords').innerHTML = `
                ${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}
            `;
            document.getElementById('centerInfo').textContent = `${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}`;
            document.getElementById('dimensionsInfo').textContent = `${width.toFixed(2)} Ã— ${height.toFixed(2)} ${unitLabel}`;
            document.getElementById('rotationInfo').textContent = `${rotationAngle.toFixed(0)}Â°`;
        }

        // Convert dimensions to different units
        function convertDimensions(widthKm, heightKm, unit) {
            const conversions = {
                km: { factor: 1, label: 'km' },
                m: { factor: 1000, label: 'm' },
                cm: { factor: 100000, label: 'cm' },
                mm: { factor: 1000000, label: 'mm' },
                mi: { factor: 0.621371, label: 'mi' },
                ft: { factor: 3280.84, label: 'ft' },
                in: { factor: 39370.1, label: 'in' }
            };
            
            const conv = conversions[unit] || conversions.km;
            
            return {
                width: widthKm * conv.factor,
                height: heightKm * conv.factor,
                unitLabel: conv.label
            };
        }

        // Update dimensions when unit changes
        document.getElementById('dimensionUnit').addEventListener('change', function() {
            updateBoundingBoxInfo();
        });

        // Apply custom dimensions button
        document.getElementById('applyDimensionsBtn').addEventListener('click', function() {
            const width = parseFloat(document.getElementById('setWidth').value);
            const height = parseFloat(document.getElementById('setHeight').value);
            const unit = document.getElementById('dimensionUnit').value;
            
            if (!width || !height || width <= 0 || height <= 0) {
                alert('Please enter valid width and height values.');
                return;
            }
            
            // Convert from selected unit to kilometers
            const conversions = {
                km: 1,
                m: 0.001,
                cm: 0.00001,
                mm: 0.000001,
                mi: 1.60934,
                ft: 0.0003048,
                in: 0.0000254
            };
            
            const factor = conversions[unit] || 1;
            const widthKm = width * factor;
            const heightKm = height * factor;
            
            // Get current center
            const bounds = boundingBox.getBounds();
            const center = bounds.getCenter();
            
            // Calculate lat/lng differences accounting for Mercator projection
            const latCorrection = Math.cos(center.lat * Math.PI / 180);
            const latDiff = heightKm / 111.32;
            const lngDiff = widthKm / (111.32 * latCorrection);
            
            // Create new corners
            const newCorners = [
                [center.lat - latDiff/2, center.lng - lngDiff/2],
                [center.lat - latDiff/2, center.lng + lngDiff/2],
                [center.lat + latDiff/2, center.lng + lngDiff/2],
                [center.lat + latDiff/2, center.lng - lngDiff/2]
            ];
            
            boundingBox.setLatLngs(newCorners);
            
            // Update base dimensions
            baseLatDiff = latDiff / 2;
            baseLngDiff = lngDiff / 2;
            
            // Reset rotation
            rotationAngle = 0;
            
            updateCorners();
            updateBoundingBoxInfo();
        });

        // Location search using Mapbox Geocoding API
        let searchTimeout;
        document.getElementById('searchInput').addEventListener('input', function(e) {
            const query = e.target.value.trim();
            const resultsDiv = document.getElementById('searchResults');
            
            if (query.length < 3) {
                resultsDiv.style.display = 'none';
                return;
            }

            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchLocation(query);
            }, 500);
        });

        async function searchLocation(query) {
            if (!query) return;
            
            try {
                const response = await fetch(
                    `/api/mapbox/geocoding?query=${encodeURIComponent(query)}`
                );
                const data = await response.json();
                
                displaySearchResults(data.features);
            } catch (error) {
                console.error('Search error:', error);
                alert('Search failed. Please check console for details.');
            }
        }

        function displaySearchResults(features) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (features.length === 0) {
                resultsDiv.style.display = 'none';
                return;
            }

            resultsDiv.innerHTML = features.map(feature => {
                const placeType = feature.place_type ? feature.place_type[0] : 'place';
                const icon = getPlaceIcon(placeType);
                return `
                    <div class="search-result-item" onclick='selectLocation(${feature.center[1]}, ${feature.center[0]}, "${feature.place_name.replace(/"/g, '&quot;')}")'>
                        <svg class="result-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            ${icon}
                        </svg>
                        <div class="result-content">
                            <div class="result-name">${feature.text}</div>
                            <div class="result-context">${feature.place_name.split(',').slice(1).join(',').trim()}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            resultsDiv.style.display = 'block';
        }
        
        function getPlaceIcon(placeType) {
            const icons = {
                'country': '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z" stroke="currentColor" stroke-width="2"/><circle cx="12" cy="10" r="3" stroke="currentColor" stroke-width="2"/>',
                'region': '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z" stroke="currentColor" stroke-width="2"/><circle cx="12" cy="10" r="3" stroke="currentColor" stroke-width="2"/>',
                'place': '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z" stroke="currentColor" stroke-width="2"/><circle cx="12" cy="10" r="3" stroke="currentColor" stroke-width="2"/>',
                'locality': '<path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" stroke="currentColor" stroke-width="2"/><path d="M9 22V12h6v10" stroke="currentColor" stroke-width="2"/>',
                'neighborhood': '<rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2"/><path d="M3 9h18M9 21V9" stroke="currentColor" stroke-width="2"/>',
                'address': '<path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2M12 11a4 4 0 100-8 4 4 0 000 8z" stroke="currentColor" stroke-width="2"/>',
                'poi': '<circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/><path d="M12 6v6l4 2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>'
            };
            return icons[placeType] || icons['place'];
        }

        function selectLocation(lat, lng, placeName) {
            // Store the selected location name
            if (placeName) {
                selectedLocationName = placeName;
            }
            
            map.setView([lat, lng], 14);
            
            // Center bounding box on location
            const bounds = boundingBox.getBounds();
            const latDiff = (bounds.getNorth() - bounds.getSouth()) / 2;
            const lngDiff = (bounds.getEast() - bounds.getWest()) / 2;
            
            // Calculate new corner positions
            const newCorners = [
                [lat - latDiff, lng - lngDiff],  // Southwest
                [lat - latDiff, lng + lngDiff],  // Southeast
                [lat + latDiff, lng + lngDiff],  // Northeast
                [lat + latDiff, lng - lngDiff]   // Northwest
            ];
            
            boundingBox.setLatLngs(newCorners);
            
            // Update base dimensions for rotation
            baseLatDiff = latDiff;
            baseLngDiff = lngDiff;
            
            updateCorners();
            updateBoundingBoxInfo();
            
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('searchInput').value = '';
        }

        // Close search results when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.search-container')) {
                document.getElementById('searchResults').style.display = 'none';
            }
        });

        // AI-Enhanced Search
        let aiSearchEnabled = true;
        async function enhanceSearchWithAI(query) {
            if (!aiSearchEnabled) return null;
            
            try {
                const response = await fetch('/api/ai/search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });
                
                if (!response.ok) {
                    aiSearchEnabled = false; // Disable if API not configured
                    return null;
                }
                
                return await response.json();
            } catch (error) {
                console.log('AI search unavailable:', error.message);
                aiSearchEnabled = false;
                return null;
            }
        }

        // AI Assistant Button
        document.getElementById('aiButton').addEventListener('click', async function() {
            showAIModal();
        });
        
        function showAIModal() {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                <rect x="4" y="4" width="16" height="16" rx="2"/>
                                <rect x="9" y="9" width="6" height="6"/>
                                <path d="M9 2V4M15 2V4M9 20V22M15 20V22M2 9H4M2 15H4M20 9H22M20 15H22" stroke-linecap="round"/>
                            </svg>
                            <h2>AI Assistant</h2>
                        </div>
                        <button class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #e0e0e0;">
                                What do you need this map for?
                            </label>
                            <textarea 
                                id="aiPurposeInput" 
                                placeholder="Examples:&#10;â€¢ Wall art for my living room&#10;â€¢ Laser engraving on wood&#10;â€¢ Printed poster (24x36 inches)&#10;â€¢ Trail planning and hiking&#10;â€¢ City planning presentation&#10;â€¢ Gift for a friend"
                                style="width: 100%; min-height: 120px; padding: 12px; background: #1e1e1e; border: 1px solid #3a3a3a; border-radius: 4px; color: #e0e0e0; font-family: inherit; font-size: 14px; resize: vertical; pointer-events: auto; user-select: text; -webkit-user-select: text;"
                            ></textarea>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn-secondary" id="aiCancelBtn" style="padding: 10px 20px; background: #3a3a3a; border: none; border-radius: 4px; color: #e0e0e0; cursor: pointer; font-size: 14px;">
                                Cancel
                            </button>
                            <button class="btn-primary" id="aiSubmitBtn" style="padding: 10px 20px; background: #4a90e2; border: none; border-radius: 4px; color: white; cursor: pointer; font-weight: 600; font-size: 14px; display: flex; align-items: center; gap: 8px;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                                </svg>
                                Get AI Recommendations
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            const input = document.getElementById('aiPurposeInput');
            const submitBtn = document.getElementById('aiSubmitBtn');
            const cancelBtn = document.getElementById('aiCancelBtn');
            
            // Focus input
            setTimeout(() => input.focus(), 100);
            
            // Close handlers
            modal.querySelector('.modal-close').addEventListener('click', () => modal.remove());
            cancelBtn.addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
            
            // Submit handler
            submitBtn.addEventListener('click', async () => {
                const purpose = input.value.trim();
                if (!purpose) {
                    input.style.borderColor = '#e74c3c';
                    return;
                }
                
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px; border-width: 2px;"></div> Processing...';
                
                try {
                    const bounds = boundingBox.getBounds();
                    const center = bounds.getCenter();
                    const style = document.getElementById('mapStyle').value;
                    const size = document.getElementById('imageSize').value;
                    
                    const response = await fetch('/api/ai/suggest', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            location: `${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}`,
                            style: style,
                            dimensions: `${size}x${size}`,
                            purpose: purpose
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        modal.remove();
                        showAIResultsModal(data, purpose);
                    } else {
                        throw new Error('AI service unavailable');
                    }
                } catch (error) {
                    console.error('AI error:', error);
                    modal.remove();
                    showErrorModal('AI assistant is not configured. Add your OpenAI API key to .env file.');
                }
            });
            
            // Enter key to submit
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    submitBtn.click();
                }
            });
        }
        
        function showAIResultsModal(data, purpose) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4a90e2" stroke-width="2">
                                <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                            </svg>
                            <h2>AI Recommendations</h2>
                        </div>
                        <button class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div style="background: #2a2a2a; border-left: 3px solid #4a90e2; padding: 16px; border-radius: 4px; margin-bottom: 20px;">
                            <div style="color: #888; font-size: 12px; margin-bottom: 4px;">PURPOSE</div>
                            <div style="color: #e0e0e0; font-style: italic;">"${purpose}"</div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 20px;">
                            <div style="background: #2a2a2a; padding: 16px; border-radius: 4px;">
                                <div style="color: #4a90e2; font-size: 12px; font-weight: 600; margin-bottom: 8px;">ðŸ“ SUGGESTED STYLE</div>
                                <div style="color: #e0e0e0; font-size: 16px; font-weight: 600;">${data.suggestedStyle}</div>
                            </div>
                            <div style="background: #2a2a2a; padding: 16px; border-radius: 4px;">
                                <div style="color: #4a90e2; font-size: 12px; font-weight: 600; margin-bottom: 8px;">ðŸ“ RECOMMENDED SIZE</div>
                                <div style="color: #e0e0e0; font-size: 16px; font-weight: 600;">${data.suggestedDimensions}</div>
                            </div>
                        </div>
                        
                        <div style="background: #2a2a2a; padding: 16px; border-radius: 4px; margin-bottom: 16px;">
                            <div style="color: #4a90e2; font-size: 12px; font-weight: 600; margin-bottom: 8px;">ðŸ’¡ REASONING</div>
                            <div style="color: #b0b0b0; line-height: 1.6;">${data.reasoning}</div>
                        </div>
                        
                        <div style="background: #2a2a2a; padding: 16px; border-radius: 4px; margin-bottom: 20px;">
                            <div style="color: #4a90e2; font-size: 12px; font-weight: 600; margin-bottom: 8px;">âœ¨ TIPS</div>
                            <ul style="margin: 0; padding-left: 20px; color: #b0b0b0; line-height: 1.8;">
                                ${data.tips.map(tip => `<li>${tip}</li>`).join('')}
                            </ul>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn-secondary" id="aiDeclineBtn" style="padding: 10px 20px; background: #3a3a3a; border: none; border-radius: 4px; color: #e0e0e0; cursor: pointer; font-size: 14px;">
                                No Thanks
                            </button>
                            <button class="btn-primary" id="aiApplyBtn" style="padding: 10px 20px; background: #4a90e2; border: none; border-radius: 4px; color: white; cursor: pointer; font-weight: 600; font-size: 14px;">
                                âœ“ Apply Settings
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Close handlers
            modal.querySelector('.modal-close').addEventListener('click', () => modal.remove());
            document.getElementById('aiDeclineBtn').addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
            
            // Apply handler
            document.getElementById('aiApplyBtn').addEventListener('click', () => {
                // Apply the suggestions
                document.getElementById('mapStyle').value = data.suggestedStyle;
                
                // Parse dimensions
                const [width, height] = data.suggestedDimensions.split('x').map(s => s.trim());
                if (width && height) {
                    document.getElementById('imageSize').value = Math.max(parseInt(width), parseInt(height));
                    
                    // Set aspect ratio if not square
                    if (width !== height) {
                        const ratio = `${width}:${height}`;
                        const ratioSelect = document.getElementById('aspectRatio');
                        const options = Array.from(ratioSelect.options).map(opt => opt.value);
                        if (options.includes(ratio)) {
                            ratioSelect.value = ratio;
                        }
                    }
                }
                
                modal.remove();
                
                // Show success message
                showSuccessModal(`Settings applied! Click "Process Map" to generate with AI-optimized settings.`);
                
                // Flash the Generate button
                const generateBtn = document.getElementById('generateBtn');
                generateBtn.classList.add('flash');
                setTimeout(() => generateBtn.classList.remove('flash'), 1800);
            });
        }
        
        function showSuccessModal(message) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px; text-align: center;">
                    <div class="modal-body" style="padding: 32px;">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#27ae60" stroke-width="2" style="margin-bottom: 16px;">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M9 12l2 2 4-4"/>
                        </svg>
                        <div style="color: #e0e0e0; font-size: 16px; line-height: 1.6;">${message}</div>
                        <button class="btn-primary" style="margin-top: 20px; padding: 10px 24px; background: #4a90e2; border: none; border-radius: 4px; color: white; cursor: pointer; font-weight: 600;">
                            Got it!
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            modal.querySelector('.btn-primary').addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
            
            // Auto-close after 3 seconds
            setTimeout(() => modal.remove(), 3000);
        }
        
        function showErrorModal(message) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px; text-align: center;">
                    <div class="modal-body" style="padding: 32px;">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#e74c3c" stroke-width="2" style="margin-bottom: 16px;">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="15" y1="9" x2="9" y2="15"/>
                            <line x1="9" y1="9" x2="15" y2="15"/>
                        </svg>
                        <div style="color: #e0e0e0; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">${message}</div>
                        <button class="btn-primary" style="padding: 10px 24px; background: #3a3a3a; border: none; border-radius: 4px; color: #e0e0e0; cursor: pointer; font-weight: 600;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            modal.querySelector('.btn-primary').addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }

        // AI Map Description (called when preview opens)
        async function getAIDescription() {
            try {
                const bounds = boundingBox.getBounds();
                const center = bounds.getCenter();
                const style = document.getElementById('mapStyle').value;
                const size = document.getElementById('imageSize').value;
                const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
                
                const response = await fetch('/api/ai/describe', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        location: `${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}`,
                        bbox: bbox,
                        style: style,
                        dimensions: `${size}x${size}`
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const container = document.getElementById('aiDescriptionContainer');
                    const descElement = document.getElementById('aiDescription');
                    descElement.innerHTML = `<strong>ðŸ¤– AI Analysis:</strong><br>${data.description}`;
                    container.style.display = 'block';
                }
            } catch (error) {
                console.log('AI description unavailable:', error.message);
            }
        }

        // Lock selection toggle
        document.getElementById('lockSelectionBtn').addEventListener('click', function(e) {
            isSelectionLocked = !isSelectionLocked;
            this.classList.toggle('active', isSelectionLocked);
            this.textContent = isSelectionLocked ? 'ðŸ”“' : 'ðŸ”’';
            // Update corner markers to show locked state
            if (window.updateCorners) {
                window.updateCorners();
            }
        });

        // Lock zoom scaling toggle
        document.getElementById('lockZoomBtn').addEventListener('click', function(e) {
            isZoomLocked = !isZoomLocked;
            this.classList.toggle('active', isZoomLocked);
            this.style.background = isZoomLocked ? '#4a90e2' : '';
        });

        // Aspect ratio change handler
        // Check if current selection is square (accounting for Mercator projection)
        function checkIfSquare() {
            const bounds = boundingBox.getBounds();
            const center = bounds.getCenter();
            const latCorrection = Math.cos(center.lat * Math.PI / 180);
            
            const latDiff = bounds.getNorth() - bounds.getSouth();
            const lngDiff = bounds.getEast() - bounds.getWest();
            
            // Calculate actual aspect ratio accounting for Mercator distortion
            const adjustedLngDiff = lngDiff * latCorrection;
            const ratio = adjustedLngDiff / latDiff;
            
            // Check if ratio is close to 1:1 (within 2% tolerance)
            const isSquare = Math.abs(ratio - 1) < 0.02;
            
            const customBadge = document.getElementById('customRatioBadge');
            const squareIndicator = document.getElementById('squareIndicator');
            
            if (isSquare) {
                // Hide custom badge, show square indicator
                customBadge.classList.remove('active');
                squareIndicator.classList.add('active');
            } else {
                // Show custom badge, hide square indicator
                customBadge.classList.add('active');
                squareIndicator.classList.remove('active');
            }
        }

        // Update actual size helper text
        function updateActualSizeHelper() {
            const baseSize = parseInt(document.getElementById('imageSize').value);
            const aspectRatio = document.getElementById('aspectRatio').value;
            const [ratioW, ratioH] = aspectRatio.split(':').map(Number);
            const aspectValue = ratioW / ratioH;
            
            let width, height;
            if (aspectValue >= 1) {
                width = baseSize;
                height = Math.round(baseSize / aspectValue);
            } else {
                height = baseSize;
                width = Math.round(baseSize * aspectValue);
            }
            
            document.getElementById('actualSizeHelper').textContent = `${width}Ã—${height}`;
        }

        document.getElementById('aspectRatio').addEventListener('change', function(e) {
            updateBoundingBoxAspectRatio(e.target.value);
            // Hide both badges when preset is selected
            document.getElementById('customRatioBadge').classList.remove('active');
            document.getElementById('squareIndicator').classList.remove('active');
            // Update size helper
            updateActualSizeHelper();
        });

        // Update size helper when size changes
        document.getElementById('imageSize').addEventListener('change', updateActualSizeHelper);

        // Initialize size helper
        updateActualSizeHelper();

        function updateBoundingBoxAspectRatio(ratio) {
            const [width, height] = ratio.split(':').map(Number);
            const aspectRatio = width / height;
            
            const bounds = boundingBox.getBounds();
            const center = bounds.getCenter();
            
            // Account for latitude distortion (Mercator projection)
            const latCorrection = Math.cos(center.lat * Math.PI / 180);
            
            // Get current dimensions
            const currentLatDiff = bounds.getNorth() - bounds.getSouth();
            const currentLngDiff = bounds.getEast() - bounds.getWest();
            
            // Calculate new dimensions maintaining area roughly
            let newLatDiff, newLngDiff;
            
            if (aspectRatio >= 1) {
                // Wider than tall
                newLatDiff = Math.sqrt((currentLatDiff * currentLngDiff * latCorrection) / aspectRatio);
                newLngDiff = (newLatDiff * aspectRatio) / latCorrection;
            } else {
                // Taller than wide
                newLatDiff = Math.sqrt((currentLatDiff * currentLngDiff * latCorrection) * aspectRatio);
                newLngDiff = (newLatDiff / aspectRatio) / latCorrection;
            }
            
            // Update base dimensions for rotation
            baseLatDiff = newLatDiff / 2;
            baseLngDiff = newLngDiff / 2;
            
            // Reset rotation to 0 when changing aspect ratio
            rotationAngle = 0;
            
            // Create new corners
            const newCorners = [
                [center.lat + baseLatDiff, center.lng - baseLngDiff], // NW
                [center.lat + baseLatDiff, center.lng + baseLngDiff], // NE
                [center.lat - baseLatDiff, center.lng + baseLngDiff], // SE
                [center.lat - baseLatDiff, center.lng - baseLngDiff]  // SW
            ];
            
            boundingBox.setLatLngs(newCorners);
            
            // Update corner markers to match new corners
            if (window.updateCorners) {
                window.updateCorners();
            }
            
            updateBoundingBoxInfo();
        }

        // Generate engraving image
        document.getElementById('generateBtn').addEventListener('click', async function() {
            console.log('Generate button clicked');
            
            // Get parameters
            const bounds = boundingBox.getBounds();
            
            const mapStyleElement = document.getElementById('mapStyle');
            const imageSizeElement = document.getElementById('imageSize');
            const aspectRatioElement = document.getElementById('aspectRatio');
            
            console.log('mapStyle element:', mapStyleElement);
            console.log('mapStyle value:', mapStyleElement?.value);
            console.log('mapStyle selected option:', mapStyleElement?.options[mapStyleElement?.selectedIndex]?.value);
            console.log('imageSize element:', imageSizeElement);
            console.log('imageSize value:', imageSizeElement?.value);
            console.log('imageSize selected option:', imageSizeElement?.options[imageSizeElement?.selectedIndex]?.value);
            console.log('aspectRatio element:', aspectRatioElement);
            console.log('aspectRatio value:', aspectRatioElement?.value);
            
            // Use selectedIndex approach for hidden dropdowns
            const rawStyle = mapStyleElement?.options[mapStyleElement?.selectedIndex]?.value || 'streets-v12';
            const style = laserMode ? 'laser' : rawStyle;
            const baseSizeStr = imageSizeElement?.options[imageSizeElement?.selectedIndex]?.value || '1280';
            const baseSize = parseInt(baseSizeStr);
            const aspectRatio = aspectRatioElement?.value || '1:1';
            
            console.log('Raw style:', rawStyle);
            console.log('LaserMode active:', laserMode);
            console.log('Final style:', style);
            console.log('Base size string:', baseSizeStr);
            console.log('Parsed baseSize:', baseSize);
            console.log('Parsed aspectRatio:', aspectRatio);
            
            // Validate inputs
            if (!aspectRatio || !aspectRatio.includes(':')) {
                console.error('Invalid aspect ratio:', aspectRatio);
                alert('Invalid aspect ratio selected. Please refresh the page and try again.');
                return;
            }
            
            if (isNaN(baseSize) || baseSize < 1) {
                console.error('Invalid image size:', baseSize);
                alert('Invalid image size. Please select a valid size and try again.');
                return;
            }
            
            // Calculate width and height based on aspect ratio
            const [ratioW, ratioH] = aspectRatio.split(':').map(Number);
            
            console.log('Ratio components:', ratioW, ratioH);
            
            if (isNaN(ratioW) || isNaN(ratioH) || ratioW <= 0 || ratioH <= 0) {
                console.error('Invalid aspect ratio values:', ratioW, ratioH);
                alert('Invalid aspect ratio format. Please refresh the page and try again.');
                return;
            }
            
            const aspectValue = ratioW / ratioH;
            
            let width, height;
            if (aspectValue >= 1) {
                // Landscape or square - base size is width
                width = baseSize;
                height = Math.round(baseSize / aspectValue);
            } else {
                // Portrait - base size is height
                height = baseSize;
                width = Math.round(baseSize * aspectValue);
            }
            
            console.log('Calculated dimensions:', width, 'x', height);
            
            // Final validation
            if (isNaN(width) || isNaN(height) || width < 1 || height < 1) {
                console.error('Invalid calculated dimensions:', width, height);
                alert('Error calculating image dimensions. Please refresh the page and try again.');
                return;
            }
            
            // Build Mapbox Static Images API URL
            const bbox = [
                bounds.getWest(),
                bounds.getSouth(),
                bounds.getEast(),
                bounds.getNorth()
            ].join(',');
            
            // Mapbox Static Images API limits:
            // Standard: max 1280x1280
            // Retina (@2x): max 1280x1280 (returns 2560x2560)
            // Minimum: 1x1
            let apiWidth = width;
            let apiHeight = height;
            let useRetina = false;
            
            // Check if we need retina and ensure we stay within limits
            const maxDimension = Math.max(width, height);
            
            if (maxDimension > 1280) {
                // Use @2x for larger sizes
                const scale = 1280 / maxDimension;
                apiWidth = Math.max(1, Math.floor(width * scale));
                apiHeight = Math.max(1, Math.floor(height * scale));
                useRetina = true;
            } else {
                // Standard resolution
                apiWidth = Math.max(1, width);
                apiHeight = Math.max(1, height);
                useRetina = false;
            }
            
            console.log(`Requesting ${apiWidth}x${apiHeight}${useRetina ? '@2x' : ''} (output: ${useRetina ? apiWidth*2 : apiWidth}x${useRetina ? apiHeight*2 : apiHeight})`);
            
            const url = `/api/mapbox/static?style=${style}&bbox=${bbox}&width=${apiWidth}&height=${apiHeight}&retina=${useRetina}`;
            
            // Show loading
            document.getElementById('loadingOverlay').style.display = 'flex';
            
            try {
                console.log('Fetching image from:', url);
                
                // Fetch as blob to avoid CORS taint
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error:', errorText);
                    throw new Error(`Failed to fetch map image (status: ${response.status}). Check your API token and try again.\n\nNote: Mapbox free tier has size limits. Try a smaller output size or check your API token.`);
                }
                
                const blob = await response.blob();
                console.log('Blob received:', blob.size, 'bytes');
                
                // Create object URL from blob
                const objectURL = URL.createObjectURL(blob);
                
                const img = new Image();
                
                img.onload = function() {
                    console.log('Image loaded successfully:', img.width, 'x', img.height);
                    
                    // Store original image for live reprocessing
                    originalImageElement = img;
                    
                    // Process it
                    setTimeout(() => {
                        try {
                            processImage(img);
                            // Clean up object URL after processing
                            URL.revokeObjectURL(objectURL);
                            
                            // Navigation happens automatically inside processImage()
                            // No need to click preview button - we auto-navigate to editor page
                        } catch (err) {
                            console.error('Processing error:', err);
                            alert('Image loaded but processing failed: ' + err.message);
                            // Keep the raw image visible
                            processedImageData = objectURL;
                            document.getElementById('loadingOverlay').style.display = 'none';
                        }
                    }, 100);
                };
                
                img.onerror = function() {
                    console.error('Image failed to load from blob');
                    document.getElementById('loadingOverlay').style.display = 'none';
                    alert('Failed to load the image into canvas.');
                };
                
                img.src = objectURL;
                
            } catch (error) {
                console.error('Generation error:', error);
                alert(error.message);
                document.getElementById('loadingOverlay').style.display = 'none';
            }
        });

        // Process image for engraving
        function processImage(img) {
            console.log('Starting image processing...', img.width, img.height);
            
            // SAVE ORIGINAL IMAGE TO GLOBAL VARIABLE FOR EDITOR
            // Compress to JPEG quality 0.85 to fit in localStorage (5MB limit)
            const originalCanvas = document.createElement('canvas');
            const originalCtx = originalCanvas.getContext('2d');
            originalCanvas.width = img.width;
            originalCanvas.height = img.height;
            originalCtx.drawImage(img, 0, 0);
            originalImageData = originalCanvas.toDataURL('image/jpeg', 0.85); // JPEG at 85% quality
            console.log('Original image saved (compressed), length:', originalImageData.length);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.width;
            canvas.height = img.height;
            
            console.log('Canvas created:', canvas.width, canvas.height);
            
            // Draw image
            ctx.drawImage(img, 0, 0);
            console.log('Image drawn to canvas');
            
            // Get image data
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            console.log('Image data extracted:', data.length, 'values');
            
            // Get settings (use default threshold since main page control removed)
            const threshold = 248; // Default threshold - high value to capture light roads from streets-v12
            const edgeDetection = edgeDetectionEnabled;
            const invert = invertColorsEnabled;
            
            console.log('Processing with threshold:', threshold, 'edge:', edgeDetection, 'invert:', invert);
            
            // Store text pixels before processing (for laser+invert mode with black text option)
            let textMask = null;
            let roadMask = null;
            let waterMask = null;
            
            if (laserMode && invert && (blackTextEnabled || blackRoadsEnabled || whiteWaterEnabled)) {
                const width = canvas.width;
                const height = canvas.height;
                
                if (blackTextEnabled) {
                    console.log('Laser + Invert + Black Text: marking text pixels to preserve');
                    textMask = new Uint8Array(data.length / 4);
                    
                    // Identify text pixels (typically dark to medium gray)
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        textMask[i / 4] = (gray < 220) ? 1 : 0;
                    }
                }
                
                if (blackRoadsEnabled) {
                    console.log('Laser + Invert + Black Roads: marking road pixels');
                    roadMask = new Uint8Array(data.length / 4);
                    
                    // Roads are typically lighter gray on streets style (around 200-240)
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        // Detect light gray roads
                        roadMask[i / 4] = (gray > 200 && gray < 245) ? 1 : 0;
                    }
                }
                
                if (whiteWaterEnabled) {
                    console.log('Laser + Invert + White Water: marking water pixels');
                    waterMask = new Uint8Array(data.length / 4);
                    
                    // Water is typically light colored on streets style (240-255)
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        // Detect very light areas (likely water)
                        waterMask[i / 4] = (gray > 240) ? 1 : 0;
                    }
                }
            }
            
            // Laser mode: uses streets style, apply aggressive threshold to get pure black/white
            if (laserMode) {
                console.log('Laser mode: converting to pure black roads/text on white background');
                
                // Convert to grayscale first
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                }
                
                // Apply aggressive threshold - anything darker than 220 becomes pure black
                // This captures roads, text, and water boundaries
                const laserThreshold = 220;
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i];
                    // Below threshold = black (roads/text), above = white (background)
                    const value = gray < laserThreshold ? 0 : 255;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            } else {
                // Convert to grayscale and apply threshold
                for (let i = 0; i < data.length; i += 4) {
                    // Grayscale conversion
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    
                    // Apply threshold
                    const value = gray > threshold ? 255 : 0;
                    
                    data[i] = value;     // Red
                    data[i + 1] = value; // Green
                    data[i + 2] = value; // Blue
                }
            }
            
            console.log('Threshold applied');
            
            // If invert is enabled
            if (invert) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
                
                // Restore text to black in laser mode if black text is enabled
                if (laserMode && blackTextEnabled && textMask) {
                    console.log('Restoring text to black with white boxes around it');
                    
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // First pass: create white boxes around text (dilate)
                    const dilatedMask = new Uint8Array(textMask.length);
                    const padding = 3; // pixels of white padding around text
                    
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            
                            if (textMask[idx] === 1) {
                                // Mark this pixel and surrounding area
                                for (let dy = -padding; dy <= padding; dy++) {
                                    for (let dx = -padding; dx <= padding; dx++) {
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                            dilatedMask[ny * width + nx] = 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Second pass: fill dilated areas with white
                    for (let i = 0; i < data.length; i += 4) {
                        if (dilatedMask[i / 4] === 1) {
                            data[i] = 255;
                            data[i + 1] = 255;
                            data[i + 2] = 255;
                        }
                    }
                    
                    // Third pass: put black text on top
                    for (let i = 0; i < data.length; i += 4) {
                        if (textMask[i / 4] === 1) {
                            data[i] = 0;
                            data[i + 1] = 0;
                            data[i + 2] = 0;
                        }
                    }
                }
                
                // Force roads to black if enabled
                if (laserMode && blackRoadsEnabled && roadMask) {
                    console.log('Forcing roads to solid black');
                    for (let i = 0; i < data.length; i += 4) {
                        if (roadMask[i / 4] === 1) {
                            data[i] = 0;
                            data[i + 1] = 0;
                            data[i + 2] = 0;
                        }
                    }
                }
                
                // Force water to white if enabled
                if (laserMode && whiteWaterEnabled && waterMask) {
                    console.log('Forcing water to white');
                    for (let i = 0; i < data.length; i += 4) {
                        if (waterMask[i / 4] === 1) {
                            data[i] = 255;
                            data[i + 1] = 255;
                            data[i + 2] = 255;
                        }
                    }
                }
            }
            
            // Apply envelope warp if enabled
            if (currentEnvelopeWarp > 0) {
                console.log('Applying envelope warp:', currentEnvelopeWarp + '%');
                ctx.putImageData(imageData, 0, 0);
                const warpedCanvas = applyEnvelopeWarp(canvas, currentEnvelopeWarp);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(warpedCanvas, 0, 0);
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
            
            // Apply edge detection if enabled (but not if laser mode is already active)
            if (edgeDetection && !laserMode) {
                console.log('Applying edge detection...');
                imageData = applyEdgeDetection(imageData);
            }
            
            // Put processed data back
            ctx.putImageData(imageData, 0, 0);
            console.log('Data put back to canvas');
            
            // Convert to data URL for download
            processedImageData = canvas.toDataURL('image/png');
            console.log('Converted to data URL, length:', processedImageData.length);
            
            // Show preview using canvas directly
            const previewCanvas = document.getElementById('previewCanvas');
            const previewCtx = previewCanvas.getContext('2d');
            
            // Set canvas dimensions to match processed image
            previewCanvas.width = canvas.width;
            previewCanvas.height = canvas.height;
            
            // Copy the processed image to preview canvas
            previewCtx.drawImage(canvas, 0, 0);
            
            // Show the canvas
            previewCanvas.style.display = 'block';
            
            document.getElementById('loadingOverlay').style.display = 'none';
            
            console.log('Processing complete!');
            
            // Navigate to Professional Editor - happens automatically
            // Store ORIGINAL unprocessed image and metadata in localStorage
            try {
                localStorage.setItem('mapitImageData', originalImageData); // Use original, not processed
                
                // Build enhanced metadata safely
                const metadata = {
                    location: selectedLocationName || document.getElementById('searchInput')?.value || (map ? `${map.getCenter().lat.toFixed(4)}, ${map.getCenter().lng.toFixed(4)}` : 'Unknown'),
                    timestamp: Date.now(),
                    dimensions: `${canvas.width}Ã—${canvas.height}`
                };
                
                // Add optional fields if available
                try {
                    if (boundingBox && typeof boundingBox.getSouthWest === 'function') {
                        metadata.bbox = [
                            boundingBox.getSouthWest().lng,
                            boundingBox.getSouthWest().lat,
                            boundingBox.getNorthEast().lng,
                            boundingBox.getNorthEast().lat
                        ];
                    }
                } catch (e) {
                    console.log('Could not get bbox:', e);
                }
                
                try {
                    const styleSelect = document.getElementById('styleSelect');
                    if (styleSelect) {
                        metadata.style = styleSelect.value;
                    } else {
                        metadata.style = 'streets-v12';
                    }
                } catch (e) {
                    metadata.style = 'streets-v12';
                }
                
                try {
                    if (map && typeof map.getZoom === 'function') {
                        metadata.zoom = map.getZoom();
                        metadata.center = map.getCenter();
                    }
                } catch (e) {
                    console.log('Could not get map info:', e);
                }
                
                localStorage.setItem('mapitMetadata', JSON.stringify(metadata));
                console.log('Metadata saved:', metadata);
            } catch (e) {
                console.error('Error saving to localStorage:', e);
                alert('Failed to save image data: ' + e.message);
                return;
            }
            
            console.log('Navigating to editor page...');
            
            // Navigate to editor page
            window.location.href = '/editor';
        }

        // Remove ferry lines and dashed routes by detecting small isolated segments
        function removeDashedLines(imageData, width, height) {
            const data = imageData.data;
            const visited = new Uint8Array(width * height);
            const result = new Uint8ClampedArray(data);
            
            // Find all connected components of black pixels
            function floodFill(startX, startY) {
                const stack = [[startX, startY]];
                const component = [];
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const idx = y * width + x;
                    
                    if (x < 0 || x >= width || y < 0 || y >= height) continue;
                    if (visited[idx]) continue;
                    
                    const pixelIdx = idx * 4;
                    if (data[pixelIdx] !== 0) continue; // Not black
                    
                    visited[idx] = 1;
                    component.push([x, y]);
                    
                    // Check 8-connected neighbors
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                    stack.push([x + 1, y + 1]);
                    stack.push([x - 1, y - 1]);
                    stack.push([x + 1, y - 1]);
                    stack.push([x - 1, y + 1]);
                }
                
                return component;
            }
            
            // Analyze each connected component
            const componentsToRemove = [];
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    if (!visited[idx] && data[pixelIdx] === 0) {
                        const component = floodFill(x, y);
                        
                        if (component.length > 0) {
                            // Calculate component characteristics
                            const minX = Math.min(...component.map(p => p[0]));
                            const maxX = Math.max(...component.map(p => p[0]));
                            const minY = Math.min(...component.map(p => p[1]));
                            const maxY = Math.max(...component.map(p => p[1]));
                            
                            const compWidth = maxX - minX + 1;
                            const compHeight = maxY - minY + 1;
                            const area = component.length;
                            const boundingArea = compWidth * compHeight;
                            const density = area / boundingArea;
                            
                            // Remove small isolated segments likely to be dashed lines
                            // Criteria: small area, low density (sparse), elongated
                            const maxDimension = Math.max(compWidth, compHeight);
                            const minDimension = Math.min(compWidth, compHeight);
                            const aspectRatio = maxDimension / (minDimension + 1);
                            
                            // Remove if:
                            // - Very small (< 100 pixels) and sparse (density < 0.3)
                            // - Small (< 500 pixels) and very elongated (aspect ratio > 10) and sparse
                            if ((area < 100 && density < 0.3) ||
                                (area < 500 && aspectRatio > 10 && density < 0.4)) {
                                componentsToRemove.push(component);
                            }
                        }
                    }
                }
            }
            
            // Remove the identified components
            for (const component of componentsToRemove) {
                for (const [x, y] of component) {
                    const pixelIdx = (y * width + x) * 4;
                    result[pixelIdx] = 255;
                    result[pixelIdx + 1] = 255;
                    result[pixelIdx + 2] = 255;
                }
            }
            
            // Copy result back to imageData
            for (let i = 0; i < data.length; i++) {
                data[i] = result[i];
            }
            
            return imageData;
        }

        // Apply morphological dilation to thicken black features (text, lines)
        function applyDilation(imageData, width, height, iterations) {
            const data = imageData.data;
            const result = new Uint8ClampedArray(data);
            
            // Handle fractional iterations by doing full iterations + weighted blend
            const fullIterations = Math.floor(iterations);
            const fraction = iterations - fullIterations;
            
            // Perform full dilation iterations
            for (let iter = 0; iter < fullIterations; iter++) {
                const temp = new Uint8ClampedArray(result);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Check if any neighbor is black (0)
                        let hasBlackNeighbor = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                if (temp[nIdx] === 0) {
                                    hasBlackNeighbor = true;
                                    break;
                                }
                            }
                            if (hasBlackNeighbor) break;
                        }
                        
                        // If any neighbor is black, make this pixel black
                        if (hasBlackNeighbor) {
                            result[idx] = 0;
                            result[idx + 1] = 0;
                            result[idx + 2] = 0;
                        }
                    }
                }
            }
            
            // If there's a fractional part, apply partial dilation deterministically
            if (fraction > 0) {
                const temp = new Uint8ClampedArray(result);
                const partialResult = new Uint8ClampedArray(result);
                
                // Do one more full dilation
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        let hasBlackNeighbor = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                if (temp[nIdx] === 0) {
                                    hasBlackNeighbor = true;
                                    break;
                                }
                            }
                            if (hasBlackNeighbor) break;
                        }
                        
                        if (hasBlackNeighbor) {
                            partialResult[idx] = 0;
                            partialResult[idx + 1] = 0;
                            partialResult[idx + 2] = 0;
                        }
                    }
                }
                
                // Deterministically blend based on pixel position and fraction
                // Use checkerboard pattern for 0.5, and denser patterns for other fractions
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Only process pixels that would change in the next iteration
                        if (result[idx] === 255 && partialResult[idx] === 0) {
                            // Use deterministic pattern based on coordinates
                            // This creates a consistent dithering pattern
                            const pattern = ((x % 2) + (y % 2) * 2); // 0, 1, 2, 3 pattern
                            const threshold = pattern / 4; // 0, 0.25, 0.5, 0.75
                            
                            if (fraction > threshold) {
                                result[idx] = 0;
                                result[idx + 1] = 0;
                                result[idx + 2] = 0;
                            }
                        }
                    }
                }
            }
            
            // Copy result back to imageData
            for (let i = 0; i < data.length; i++) {
                data[i] = result[i];
            }
            
            return imageData;
        }

        // Simple edge detection (Sobel operator)
        function applyEdgeDetection(imageData) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            
            ctx.putImageData(imageData, 0, 0);
            
            const src = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const dst = ctx.createImageData(canvas.width, canvas.height);
            
            const sobelX = [
                [-1, 0, 1],
                [-2, 0, 2],
                [-1, 0, 1]
            ];
            
            const sobelY = [
                [-1, -2, -1],
                [0, 0, 0],
                [1, 2, 1]
            ];
            
            for (let y = 1; y < canvas.height - 1; y++) {
                for (let x = 1; x < canvas.width - 1; x++) {
                    let pixelX = 0;
                    let pixelY = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * canvas.width + (x + kx)) * 4;
                            const gray = src.data[idx];
                            pixelX += gray * sobelX[ky + 1][kx + 1];
                            pixelY += gray * sobelY[ky + 1][kx + 1];
                        }
                    }
                    
                    const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                    const idx = (y * canvas.width + x) * 4;
                    const value = magnitude > 50 ? 0 : 255;
                    
                    dst.data[idx] = value;
                    dst.data[idx + 1] = value;
                    dst.data[idx + 2] = value;
                    dst.data[idx + 3] = 255;
                }
            }
            
            return dst;
        }

        // Apply envelope warp (barrel distortion) to compensate for engraving curvature
        function applyEnvelopeWarp(sourceCanvas, warpLevel) {
            const warpCanvas = document.createElement('canvas');
            const warpCtx = warpCanvas.getContext('2d');
            
            warpCanvas.width = sourceCanvas.width;
            warpCanvas.height = sourceCanvas.height;
            
            const sourceData = sourceCanvas.getContext('2d').getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            const destData = warpCtx.createImageData(sourceCanvas.width, sourceCanvas.height);
            
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Warp strength: -1% to -4% creates barrel distortion (negative pincushion)
            const strength = -warpLevel * 0.01;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Normalize coordinates to -1 to 1
                    const normX = (x - centerX) / centerX;
                    const normY = (y - centerY) / centerY;
                    
                    // Calculate distance from center
                    const distance = Math.sqrt(normX * normX + normY * normY);
                    
                    // Apply barrel distortion formula
                    const distortionFactor = 1 + strength * distance * distance;
                    
                    // Calculate source coordinates
                    const srcX = centerX + normX * centerX * distortionFactor;
                    const srcY = centerY + normY * centerY * distortionFactor;
                    
                    // Bilinear interpolation for smooth results
                    if (srcX >= 0 && srcX < width - 1 && srcY >= 0 && srcY < height - 1) {
                        const x0 = Math.floor(srcX);
                        const x1 = x0 + 1;
                        const y0 = Math.floor(srcY);
                        const y1 = y0 + 1;
                        
                        const fx = srcX - x0;
                        const fy = srcY - y0;
                        
                        const destIndex = (y * width + x) * 4;
                        
                        for (let c = 0; c < 4; c++) {
                            const i00 = (y0 * width + x0) * 4 + c;
                            const i10 = (y0 * width + x1) * 4 + c;
                            const i01 = (y1 * width + x0) * 4 + c;
                            const i11 = (y1 * width + x1) * 4 + c;
                            
                            const v0 = sourceData.data[i00] * (1 - fx) + sourceData.data[i10] * fx;
                            const v1 = sourceData.data[i01] * (1 - fx) + sourceData.data[i11] * fx;
                            
                            destData.data[destIndex + c] = v0 * (1 - fy) + v1 * fy;
                        }
                    } else {
                        // Fill with white for out-of-bounds
                        const destIndex = (y * width + x) * 4;
                        destData.data[destIndex] = 255;
                        destData.data[destIndex + 1] = 255;
                        destData.data[destIndex + 2] = 255;
                        destData.data[destIndex + 3] = 255;
                    }
                }
            }
            
            warpCtx.putImageData(destData, 0, 0);
            return warpCanvas;
        }

        // Modal Controls
        document.getElementById('openPreviewBtn')?.addEventListener('click', function() {
            if (!originalImageElement) return;
            
            // Reset zoom and pan
            previewZoom = 1;
            previewPanX = 0;
            previewPanY = 0;
            document.getElementById('zoomLevel').textContent = '100%';
            
            // Sync settings to modal
            document.getElementById('modalEdgeDetection').checked = edgeDetectionEnabled;
            document.getElementById('modalInvertColors').checked = invertColorsEnabled;
            document.getElementById('modalImageSize').value = document.getElementById('imageSize').value;
            document.getElementById('modalAspectRatio').value = document.getElementById('aspectRatio').value;
            
            // Copy selection info from map overlay
            const centerText = document.getElementById('centerInfo').textContent;
            const dimensionsText = document.getElementById('dimensionsInfo').textContent;
            document.getElementById('modalSelectionInfo').innerHTML = `
                <strong>Center:</strong> ${centerText}<br>
                <strong>Dimensions:</strong> ${dimensionsText}
            `;
            
            // Get AI description
            getAIDescription();
            
            // Process image in modal
            processImageForModal(originalImageElement);
            
            // Show modal
            document.getElementById('previewModal').classList.add('active');
        });

        // Preview zoom controls
        document.getElementById('zoomIn').addEventListener('click', function() {
            previewZoom = Math.min(previewZoom + 0.25, 5);
            document.getElementById('zoomLevel').textContent = Math.round(previewZoom * 100) + '%';
            redrawModalPreview();
        });
        
        document.getElementById('zoomOut').addEventListener('click', function() {
            previewZoom = Math.max(previewZoom - 0.25, 0.25);
            document.getElementById('zoomLevel').textContent = Math.round(previewZoom * 100) + '%';
            redrawModalPreview();
        });
        
        document.getElementById('zoomReset').addEventListener('click', function() {
            previewZoom = 1;
            previewPanX = 0;
            previewPanY = 0;
            document.getElementById('zoomLevel').textContent = '100%';
            redrawModalPreview();
        });
        
        // Scroll wheel zoom
        const modalCanvas = document.getElementById('modalPreviewCanvas');
        modalCanvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            previewZoom = Math.max(0.25, Math.min(5, previewZoom + delta));
            document.getElementById('zoomLevel').textContent = Math.round(previewZoom * 100) + '%';
            redrawModalPreview();
        });
        
        // Pan with mouse drag
        modalCanvas.addEventListener('mousedown', function(e) {
            isPanning = true;
            panStartX = e.clientX - previewPanX;
            panStartY = e.clientY - previewPanY;
        });
        
        modalCanvas.addEventListener('mousemove', function(e) {
            if (isPanning) {
                previewPanX = e.clientX - panStartX;
                previewPanY = e.clientY - panStartY;
                redrawModalPreview();
            }
        });
        
        modalCanvas.addEventListener('mouseup', function() {
            isPanning = false;
        });
        
        modalCanvas.addEventListener('mouseleave', function() {
            isPanning = false;
        });
        
        // Redraw modal preview with zoom and pan
        function redrawModalPreview() {
            if (!previewBaseImage) return;
            
            const canvas = document.getElementById('modalPreviewCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            
            // Apply pan and zoom
            ctx.translate(previewPanX + canvas.width / 2, previewPanY + canvas.height / 2);
            ctx.scale(previewZoom, previewZoom);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            ctx.drawImage(previewBaseImage, 0, 0);
            ctx.restore();
        }

        document.getElementById('closeModal').addEventListener('click', function() {
            document.getElementById('previewModal').classList.remove('active');
        });

        // Close modal on outside click
        document.getElementById('previewModal').addEventListener('click', function(e) {
            if (e.target === this) {
                this.classList.remove('active');
            }
        });

        // Modal control listeners with live preview
        document.getElementById('modalContrastThreshold').addEventListener('input', function(e) {
            const value = e.target.value;
            document.getElementById('modalThresholdValue').textContent = value;
            document.getElementById('modalContrastThresholdInput').value = value;
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        // Sync manual modal threshold input with slider
        document.getElementById('modalContrastThresholdInput').addEventListener('input', function(e) {
            const value = Math.max(0, Math.min(255, parseInt(e.target.value) || 0));
            document.getElementById('modalContrastThreshold').value = value;
            document.getElementById('modalThresholdValue').textContent = value;
            this.value = value;
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        document.getElementById('modalEdgeDetection').addEventListener('change', function() {
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        document.getElementById('modalInvertColors').addEventListener('change', function() {
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });
        
        document.getElementById('modalBlackText').addEventListener('change', function() {
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        // Thicken text checkbox and slider
        document.getElementById('thickenTextCheck').addEventListener('change', function() {
            const isChecked = this.checked;
            document.getElementById('thickenAmountControl').style.display = isChecked ? 'block' : 'none';
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        document.getElementById('thickenAmount').addEventListener('input', function(e) {
            const value = e.target.value;
            document.getElementById('thickenAmountValue').textContent = value;
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        document.getElementById('blackTextCheck').addEventListener('change', function() {
            blackTextEnabled = this.checked;
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        document.getElementById('blackRoadsCheck').addEventListener('change', function() {
            blackRoadsEnabled = this.checked;
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        document.getElementById('whiteWaterCheck').addEventListener('change', function() {
            whiteWaterEnabled = this.checked;
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        document.getElementById('removeFerryLinesCheck').addEventListener('change', function() {
            if (originalImageElement) {
                processImageForModal(originalImageElement);
            }
        });

        // Modal aspect ratio change - sync to main and regenerate
        document.getElementById('modalAspectRatio').addEventListener('change', function(e) {
            const newRatio = e.target.value;
            document.getElementById('aspectRatio').value = newRatio;
            updateBoundingBoxAspectRatio(newRatio);
            // Regenerate with new aspect ratio
            generateImage();
        });

        // Modal image size change - sync to main and regenerate
        document.getElementById('modalImageSize').addEventListener('change', function(e) {
            const newSize = e.target.value;
            document.getElementById('imageSize').value = newSize;
            // Regenerate with new size
            generateImage();
        });

        // Process image for modal canvas
        function processImageForModal(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            
            // Get modal settings
            const threshold = parseInt(document.getElementById('modalContrastThreshold').value);
            const edgeDetection = document.getElementById('modalEdgeDetection').checked;
            const invert = document.getElementById('modalInvertColors').checked;
            const blackText = document.getElementById('modalBlackText').checked;
            const thickenText = document.getElementById('thickenTextCheck').checked;
            const thickenAmount = parseFloat(document.getElementById('thickenAmount').value);
            const removeFerryLines = document.getElementById('removeFerryLinesCheck').checked;
            
            // Store text mask if black text is enabled and invert is on
            let textMask = null;
            if (blackText && invert) {
                textMask = new Uint8Array(data.length / 4);
                // Identify dark pixels as text before processing
                for (let i = 0; i < data.length; i += 4) {
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    // Catch text including lighter labels (< 200)
                    textMask[i / 4] = (gray < 200) ? 1 : 0;
                }
            }
            
            // Convert to grayscale and apply threshold
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                const value = gray > threshold ? 255 : 0;
                
                data[i] = value;
                data[i + 1] = value;
                data[i + 2] = value;
            }
            
            // If invert is enabled, simply invert colors
            if (invert) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
                
                // Restore text to black if blackText is enabled
                if (blackText && textMask) {
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // First pass: create white boxes around text (dilate)
                    const dilatedMask = new Uint8Array(textMask.length);
                    const padding = 3; // pixels of white padding around text
                    
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            
                            if (textMask[idx] === 1) {
                                // Mark this pixel and surrounding area
                                for (let dy = -padding; dy <= padding; dy++) {
                                    for (let dx = -padding; dx <= padding; dx++) {
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                            dilatedMask[ny * width + nx] = 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Second pass: fill dilated areas with white
                    for (let i = 0; i < data.length; i += 4) {
                        if (dilatedMask[i / 4] === 1) {
                            data[i] = 255;
                            data[i + 1] = 255;
                            data[i + 2] = 255;
                        }
                    }
                    
                    // Third pass: put black text on top
                    for (let i = 0; i < data.length; i += 4) {
                        if (textMask[i / 4] === 1) {
                            data[i] = 0;
                            data[i + 1] = 0;
                            data[i + 2] = 0;
                        }
                    }
                }
            }
            
            // Apply thickening (morphological dilation) if enabled
            if (thickenText) {
                imageData = applyDilation(imageData, canvas.width, canvas.height, thickenAmount);
                data = imageData.data;
            }
            
            // Remove ferry lines and dashed routes if enabled
            if (removeFerryLines) {
                imageData = removeDashedLines(imageData, canvas.width, canvas.height);
                data = imageData.data;
            }
            
            if (edgeDetection) {
                imageData = applyEdgeDetection(imageData);
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Store processed canvas as base image for zoom/pan
            previewBaseImage = canvas;
            
            // Update modal preview
            const modalCanvas = document.getElementById('modalPreviewCanvas');
            const modalCtx = modalCanvas.getContext('2d');
            
            modalCanvas.width = canvas.width;
            modalCanvas.height = canvas.height;
            
            // Initial draw with zoom/pan applied
            redrawModalPreview();
            
            // Update processedImageData for download
            processedImageData = canvas.toDataURL('image/png');
        }

        // Modal download button
        document.getElementById('modalDownloadBtn').addEventListener('click', function() {
            if (!processedImageData) return;
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.download = `map-engraving-${timestamp}.png`;
            link.href = processedImageData;
            link.click();
        });

        // Copy to clipboard button
        document.getElementById('copyToClipboardBtn').addEventListener('click', async function() {
            if (!processedImageData) return;
            
            try {
                // Convert data URL to blob
                const response = await fetch(processedImageData);
                const blob = await response.blob();
                
                // Copy to clipboard
                await navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]);
                
                // Visual feedback
                const btn = this;
                const originalText = btn.innerHTML;
                btn.innerHTML = 'Copied!';
                btn.style.background = '#218838';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '#28a745';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy image:', err);
                alert('Failed to copy image to clipboard. Your browser may not support this feature.');
            }
        });

        // Regenerate button
        document.getElementById('regenerateBtn').addEventListener('click', function() {
            // Close modal
            document.getElementById('previewModal').style.display = 'none';
            
            // Trigger generate button
            document.getElementById('generateBtn').click();
        });

        // Clear selection button
        document.getElementById('clearSelectionBtn').addEventListener('click', function() {
            if (boundingBox && map) {
                // Reset to default bounds
                const center = map.getCenter();
                const zoom = map.getZoom();
                
                // Create default size bounding box at current center
                const latOffset = 0.05 / Math.pow(2, zoom - 13);
                const lngOffset = 0.05 / Math.pow(2, zoom - 13);
                
                const bounds = [
                    [center.lat - latOffset, center.lng - lngOffset],
                    [center.lat + latOffset, center.lng + lngOffset]
                ];
                
                boundingBox.setBounds(bounds);
                rotationAngle = 0;
                updateBBoxInfo();
                
                // Reset processed image
                processedImageData = null;
                
                // Visual feedback
                const btn = this;
                const originalBg = btn.style.background;
                btn.style.background = '#c82333';
                setTimeout(() => {
                    btn.style.background = originalBg;
                }, 200);
            }
        });

        // Initialize app
        initMap();
    </script>
</body>
</html>
